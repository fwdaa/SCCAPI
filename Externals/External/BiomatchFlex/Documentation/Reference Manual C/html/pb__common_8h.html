<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>BioMatch Flex H Toolkit For Windows: pb_common.h File Reference</title>
<link href="pb_style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>pb_common.h File Reference</h1>BioMatch Common Header File. <a href="#_details">More...</a>
<p>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;winscard.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpb__image__t.html">pb_image_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Precise Biometrics image data type.  <a href="structpb__image__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Calling convention</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#17b2e1c72f87d0b57dfe84de3a856825">PBCALL</a>&nbsp;&nbsp;&nbsp;__cdecl</td></tr>

<tr><td colspan="2"><div class="groupHeader">BioMatch boolean</div></td></tr>
<tr><td colspan="2"><div class="groupText">The standard convention for boolean values in C is to use an 'int'. Furthermore, the C standard says that 0 is treated as 'false' and all other values as 'true', but the built-in logical operators will always return 1 as 'true'. The same convention is used in BioMatch; the Boolean parameters are declared as 'int', non-zero in-parameters are treated as 'true', but functions returning boolean values will only return 0 or 1. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#115a9d387670c249cc134d22d225dbb7">PB_TRUE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#fab6fc2e90af58fd9df23e12fdb4b640">PB_FALSE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><div class="groupHeader">Error codes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="error"></a><p>
Error codes are reserved for real errors (such as there is not enough memory for the function to succeed), so a function may return "success" even if it in some sense does fail. For example, a failed match return success, but an out-parameter will communicate that the matching failed.<br>
<br>
 All such error codes (that are not mentioned in the function definitions) may however be regarded as "catastrophic failures", in the sense that they should not be able to happen, and the only sensible thing to do for a caller that receives such an error is to exit (preferably after informing the user that something unexpected has happened.) The out-parameters should be considered to have "undefined" values when a function returns an error code different from <a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a>. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#b212572ab6ebcc185e14764fa7d64dd4">PB_EBUFFER</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#066b0661e64e00ca77b4ae6ca7eeadd6">PB_EFATAL</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#501dfccee6304850eeb194621ffea6e6">PB_EBIR</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#4f864119ceaf4796f9ee9ca43f176601">PB_EDATA</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#e2c7b90d6994d411b0f501928817a58a">PB_EREADER</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#66398a36467839143f4641720614d305">PB_EMEMORY</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#edcc9a352cbc3750acf722748bda85f7">PB_EINIT</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#67744d9b2058094c0b99c1c30ad81224">PB_ESUPPORT</a>&nbsp;&nbsp;&nbsp;13</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#ad7732a17769ec4249938dcd04708274">PB_EPARAMETER</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#7e34dce8bbe7a4371cb2fbb3fd41aec1">PB_EBUSY</a>&nbsp;&nbsp;&nbsp;15</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#2e709718f80fa55c00ec2155ed631859">PB_EQUALITY</a>&nbsp;&nbsp;&nbsp;23</td></tr>

<tr><td colspan="2"><div class="groupHeader">Fingerprint Information</div></td></tr>
<tr><td colspan="2"><div class="groupText">Fingerprint detailed information in BioMatch toolkit.<p>
<a class="anchor" name="quality"></a> <dl class="user" compact><dt><b>Finger Quality </b></dt><dd>The quality value details the quality of an image. It is coded in the same way as in BioAPI, that is, in the range 0-100, with the following interpretation.</dd></dl>
0-25: UNACCEPTABLE: The biometric data cannot be used for the purpose specified by the caller.<br>
 26-50: MARGINAL: The biometric data will provide poor performance for the purpose specified by the caller and in most application environments will compromise the intent of the application. The biometric data should be replaced with a new sample.<br>
 51-75: ADEQUATE: The biometric data will provide good performance in most application environments based on the purpose specified by the caller.<br>
 76-100: EXCELLENT: The biometric data will provide good performance for the purpose specified by the caller.<br>
<p>
The values -1 and -2 have a special meaning:<br>
 -1: NOT SET: Output parameters may be set to this if the function fails.<br>
 -2: NOT SUPPORTED: Quality measurement is not supported by the implementation.<br>
<p>
The returned quality parameter only reports if the image is acceptable or not, i.e. it does not have the granularity to say if an acceptable image is of a better quality than another acceptable image. It is in general better to ignore the quality value, and just look at the finger condition value.<p>
<dl class="user" compact><dt><b>Finger Conditions</b></dt><dd>The following different conditions for a fingerprint are defined in the toolkit.</dd></dl>
<a class="anchor" name="condition"></a><p>
Knowing the quality of the finger in an image is vital for a successful implementation. The following indicators can be given from pb_finger_status. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#2f7b5110e4921f8057d6192a6b6b2613">PB_STATUS_OK</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#ed3c38285f5c4dbdf101adef5d901581">PB_STATUS_TOO_WET</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#f395839c91614d309857d66537dedf0d">PB_STATUS_TOO_DRY</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#a655808ea246de90c59ef7e04b6e133d">PB_STATUS_TOO_SMALL</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#2b2a852753ed220a95a4e8d70d539a93">PB_STATUS_BAD_FINGER</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#6f33200f731b85611cf906f4c811d5ca">PB_STATUS_UNKNOWN</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td colspan="2"><div class="groupHeader">Timeout</div></td></tr>
<tr><td colspan="2"><div class="groupText">Pre-defined timeout values. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a>&nbsp;&nbsp;&nbsp;UINT_MAX</td></tr>

<tr><td colspan="2"><div class="groupHeader">Security settings</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="FAR"></a><p>
Depending on what the system is going to be used for, different FAR levels can be chosen. The FAR level is specified during enrollment and the specified level is stored on the smart card as a part of the secure reference data. Though any numerical level may be chosen, five predefined FAR parameters are specified and the FAR for each is shown in the table below. For example, PB_FAR_10000 means that 10,000 imposter attempts, i.e. 10,000 fingers, are on average needed to produce one (1) false accept. <br>
<br>
 The FAR is inversely related to the FRR such that a decreasing FAR will result in an increasing FRR, e.g. PB_FAR_100 in the table will result in a much lower FRR than PB_FAR_1000000. Therefore it is recommended not to choose a lower FAR level than required by the system. A FAR value of 1:10,000 (PB_FAR_10000) is recommended unless the customer explicitly wants a lower value. The FRR is not only dependent on the FAR, but also on a lot of abstract parameters, such as: <br>
<br>
<ul>
<li>The users experience of the fingerprint reader.<br>
</li><li>The quality of the enrolled fingerprint template.<br>
</li><li>The skin condition of the users fingerprint.<br>
</li><li>When the last cleaning of the fingerprint sensor was made.<br>
 <br>
</li></ul>
<p>
This implies that different individuals will achieve different FRR although the same FAR level is used. A custom FAR is generated by the division 0x7fffffff/n where n is the required FAR level. So 0x7fffffff/10000 is equivalent to PB_FAR_10000. The FRR will always be optimized to be as low as possible given a specific FAR level. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#6a9705a7628f1c867fbf60dc483492d1">PB_FAR_100</a>&nbsp;&nbsp;&nbsp;(0x7fffffff/100)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#6bebb8244e3f6758f210f70161dc6e77">PB_FAR_1000</a>&nbsp;&nbsp;&nbsp;(0x7fffffff/1000)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#3b16705f626af76456af024ead76756b">PB_FAR_10000</a>&nbsp;&nbsp;&nbsp;(0x7fffffff/10000)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#2357e0f22f592e016aafaaf1e697e3d9">PB_FAR_100000</a>&nbsp;&nbsp;&nbsp;(0x7fffffff/100000)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#333ae62a4f294ce8ff6c9aeb583af1ba">PB_FAR_1000000</a>&nbsp;&nbsp;&nbsp;(0x7fffffff/1000000)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Image encoding</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="encoded"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#9d84d45c3776b3e773851ba8304d503f">PB_ENCODING_8_BIT_GRAYSCALE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><div class="groupHeader">Finger Position</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="finger"></a><p>
Individual finger positions are encoded in the same way as ANSI378-2004 and ISO19794-2 First Edition, as described in ANSI/NIST-ITL 1-2000. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#b025dd4142d15984442cb2d572bdef60">PB_FINGER_UNKNOWN</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#7f5e91b44fcfbdb753151cbda383671e">PB_FINGER_RIGHT_THUMB</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c3ded29cdafd0eda7e13a55c3accca58">PB_FINGER_RIGHT_INDEX</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#93b64306a81efbd62a6136bf867ef9a2">PB_FINGER_RIGHT_MIDDLE</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#5f5ec85db03a813a9d27850094982bc1">PB_FINGER_RIGHT_RING</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#d3f2b32c73315f92fbfa129512d64ade">PB_FINGER_RIGHT_LITTLE</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#2ccbb4dfed470ddd1ae8909fe01d3916">PB_FINGER_LEFT_THUMB</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#e78a747f9cd2d267218fc1f17cb2751d">PB_FINGER_LEFT_INDEX</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#f2483011c6318a9bbd63c4f9d4336b43">PB_FINGER_LEFT_MIDDLE</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#99830e22d52d09cb6004607e168d38b4">PB_FINGER_LEFT_RING</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#67c840ec2cdeb13d6103f7a9f8445353">PB_FINGER_LEFT_LITTLE</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td colspan="2"><div class="groupHeader">Sensors &amp; Fingerprint readers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sensor"></a><p>
Knowing what type of sensor that was used when capturing a fingerprint image can improve the biometric performance. The following readers / sensors are currently recognized by Precise BioMatch. Some sensors / readers share the same values as they are treated the same way internally. When constructing a fingerprint image with data from an external source the preferred value is <a class="el" href="pb__common_8h.html#a6c8c689a4e58d792692d42e7c8ddb9a">PB_SENSOR_UNKNOWN</a> unless that exact sensor is listed below. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#a6c8c689a4e58d792692d42e7c8ddb9a">PB_SENSOR_UNKNOWN</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#d1c222564233aa6e49dba5138f08d353">PB_SENSOR_AUTHENTEC_AES2501</a>&nbsp;&nbsp;&nbsp;17</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#4eea749e7271b755e65813e5214785c6">PB_SENSOR_AUTHENTEC_AES2550</a>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#5f7e9172331ba64ba1ffd5505e1e2ba0">PB_SENSOR_AUTHENTEC_AES2810</a>&nbsp;&nbsp;&nbsp;25</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#a0748e14a227a84f315d4800e506d1e2">PB_SENSOR_UPEK_TCS1</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#6f983921c89a34a2862115a0fd35643f">PB_SENSOR_UPEK_TCS2</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#fe797370d55152a40acbe5aec5b80935">PB_SENSOR_UPEK_TCS3</a>&nbsp;&nbsp;&nbsp;21</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#0479654ddb318184dfbcd2c3366f022a">PB_SENSOR_UPEK_TCS4</a>&nbsp;&nbsp;&nbsp;22</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#b81bc3300fcea140469394cd36cbbf09">PB_SENSOR_UPEK_TCS5</a>&nbsp;&nbsp;&nbsp;26</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#dd05b9057622a2159add9a7e37934714">PB_SENSOR_CROSSMATCH_300LC</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#8b07407da7f8bd5fa163bd1f717a2d1e">PB_SENSOR_PRECISE_100XS</a>&nbsp;&nbsp;&nbsp;17</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#04ad006b7a966220cb270263d31031e8">PB_SENSOR_PRECISE_200MC</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#8f2ba0f004a6ee5ef2dbcfe9d4f347c7">PB_SENSOR_PRECISE_250MC</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(PBCALL *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> )(int, void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BioMatch callback definition.  <a href="#9bb29114ecef59668af1dcad6f1f2d89"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25">pb_cb_cancel</a> (int token)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels an on-going operation from within an image callback.  <a href="#abd25f630b7f7afce0c952e8e2014c25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#97fa4ba22ab346635ca0d8187b828fc4">pb_cb_finger_status</a> (int token, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image, int *quality, int *condition, int *present)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides "live" information about finger on the sensor.  <a href="#97fa4ba22ab346635ca0d8187b828fc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#feca05cec126da90f3dd2b2cea798801">pb_cb_get_image_for_viewing</a> (int token, unsigned int size_X, unsigned int size_Y, unsigned int stride_X, unsigned char **image_data, unsigned int *image_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a grayscale image that is suitable for use as user feedback on finger placement.  <a href="#feca05cec126da90f3dd2b2cea798801"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342">pb_free</a> (void *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees allocated memory.  <a href="#c5cec678c539fa81f0e880a07559c342"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87">pb_free_image</a> (<a class="el" href="structpb__image__t.html">pb_image_t</a> *image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees allocated memory.  <a href="#8d09e1938d16493143f911fd706c1e87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#76a6bb3424d9fd339503d679306ed7f0">pb_initialize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the BioMatch framework.  <a href="#76a6bb3424d9fd339503d679306ed7f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#b85a0f6c194614aa46760d0120858301">pb_release</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the BioMatch framework.  <a href="#b85a0f6c194614aa46760d0120858301"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#7830f5e5237d7624777975f4d7025e2b">pb_list_readersA</a> (LPSTR *reader_list, int *nof_readers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lists available readers.  <a href="#7830f5e5237d7624777975f4d7025e2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#3eec9d407857b45f679408ae41e89973">pb_list_readersW</a> (LPWSTR *reader_list, int *nof_readers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#6ca5614c5183cf8c8a37285e4ad17879">pb_capture_imageA</a> (const LPSTR reader, unsigned int timeout, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Captures an image from the sensor.  <a href="#6ca5614c5183cf8c8a37285e4ad17879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c7898e44078e2921752734f03e8b59a7">pb_capture_imageW</a> (const LPWSTR reader, unsigned int timeout, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#ffa3796efc51c08da8b72b6e79356ed7">pb_wait_for_no_fingerA</a> (const LPSTR reader, unsigned int timeout, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Captures images from the sensor until an empty image is received.  <a href="#ffa3796efc51c08da8b72b6e79356ed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#15a117241d98249f91523f983694978c">pb_wait_for_no_fingerW</a> (const LPWSTR reader, unsigned int timeout, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c7b212b7f6d2405a7f7a6cd2d735ca35">pb_capture_raw_imageA</a> (const LPSTR reader, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Capture a raw image.  <a href="#c7b212b7f6d2405a7f7a6cd2d735ca35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#dff5b1a1b9bcdca34d547795a7a1ed64">pb_capture_raw_imageW</a> (const LPWSTR reader, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c5603df153da35996be585f8580075df">pb_sc_capture_image</a> (SCARDHANDLE reader, unsigned int timeout, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Captures an image from the sensor.  <a href="#c5603df153da35996be585f8580075df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c3866df20ad1dd9684b47bdc8067fc51">pb_sc_cancel</a> (SCARDHANDLE reader)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#974b05a59e48fb0c8ed728be1d2816bd">pb_sc_capture_raw_image</a> (SCARDHANDLE reader, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#81b6d96ac408ac0d118417c36a19c7a5">pb_sc_wait_for_no_finger</a> (SCARDHANDLE reader, unsigned int timeout, <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a> callback, void *context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#664e2c5774e64e4076c368598cf98245">pb_finger_status</a> (const <a class="el" href="structpb__image__t.html">pb_image_t</a> *image, int *quality, int *condition, int *present)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves information about the finger in an image.  <a href="#664e2c5774e64e4076c368598cf98245"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#c115c0785490e7c2bf2190f355bbfdaa">pb_get_image_for_viewing</a> (const <a class="el" href="structpb__image__t.html">pb_image_t</a> *image, unsigned int size_X, unsigned int size_Y, unsigned int stride_X, unsigned char **image_data, unsigned int *image_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a grayscale image that is suitable for use as user feedback on finger placement.  <a href="#c115c0785490e7c2bf2190f355bbfdaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#50211bd821e0c52b4a309690cdfda0bd">pb_image_to_bmp_buffer</a> (const <a class="el" href="structpb__image__t.html">pb_image_t</a> *image, unsigned char **bmp_image_buffer, unsigned int *buffer_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to a bitmap file format buffer.  <a href="#50211bd821e0c52b4a309690cdfda0bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#85649e73a8a8a799b55fda0782f8e71f">pb_bmp_buffer_to_image</a> (const unsigned char *bmp_image_buffer, unsigned int buffer_length, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a bitmap image data stream to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image.  <a href="#85649e73a8a8a799b55fda0782f8e71f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#738a5f7e7cef6b4596f15c2d16f657f7">pb_image_to_wsq_buffer</a> (const <a class="el" href="structpb__image__t.html">pb_image_t</a> *image, unsigned char **wsq_image_buffer, unsigned int *buffer_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to a wsq file format buffer.  <a href="#738a5f7e7cef6b4596f15c2d16f657f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#3e98826aa2d9c5a0c98d53623779c3c8">pb_wsq_buffer_to_image</a> (const unsigned char *wsq_image_buffer, unsigned int buffer_length, <a class="el" href="structpb__image__t.html">pb_image_t</a> **image)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a wsq image data stream to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image.  <a href="#3e98826aa2d9c5a0c98d53623779c3c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#33e96e8226ec65988f381a467d95c418">pb_cancelA</a> (LPSTR reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels an on-going operation.  <a href="#33e96e8226ec65988f381a467d95c418"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int PBCALL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pb__common_8h.html#3741448b4232e490d8bdad93f8960ada">pb_cancelW</a> (LPWSTR reader)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
BioMatch Common Header File. 
<p>
Contains the core definitions and functionality for Precise Biometrics BioMatch technology and reader intergration. <a class="anchor" name="acronyms"></a> <dl class="user" compact><dt><b>Acronyms</b></dt><dd><ul>
<li>ANSI - American National Standards Institute</li><li>FAR - False Acceptance Rate</li><li>FRR - False Rejection Rate</li><li>ISO - International Standards Organization</li><li>MoC - Match-On-Card</li><li>NIST - National Institute of Standards and Technology</li><li>SDK - Software Development Kit</li></ul>
</dd></dl>
<a class="anchor" name="ASCII"></a> <a class="anchor" name="UNICODE"></a> <dl class="user" compact><dt><b>ASCII and UNICODE</b></dt><dd>The main way of selecting the reader to use in an operation is by it's friendly name. The toolkit have support for both ASCII and UNICODE strings. All functions that uses strings are implemented as both an ASCII version and a UNICODE version. ASCII versions of a functions have a 'A' appended to it's name while the UNICODE version have a 'W' appended. The 'A' and 'W' function should not be called directly. The user should call the defined funcion wihtout 'A' and 'W'. In this way the correct implementation of the function is always selected according to the build environment. The user should for example call pb_cancel instead of <a class="el" href="pb__common_8h.html#33e96e8226ec65988f381a467d95c418" title="Cancels an on-going operation.">pb_cancelA()</a>/pb_cancelW() directly. <div class="fragment"><pre class="fragment"><span class="comment">//example how pb_cancel is defined.</span>
<span class="preprocessor">#ifdef UNICODE</span>
<span class="preprocessor"></span><span class="preprocessor">#define pb_cancel pb_cancelW</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#define pb_cancel pb_cancelA</span>
<span class="preprocessor">#endif</span>
</pre></div> The following functions has both an ASCII and a UNICODE implementation.<br>
<ul>
<li>pb_cancel {<a class="el" href="pb__common_8h.html#33e96e8226ec65988f381a467d95c418" title="Cancels an on-going operation.">pb_cancelA()</a>, <a class="el" href="pb__common_8h.html#3741448b4232e490d8bdad93f8960ada">pb_cancelW()</a>}<br>
</li><li>pb_capture_image {<a class="el" href="pb__common_8h.html#6ca5614c5183cf8c8a37285e4ad17879" title="Captures an image from the sensor.">pb_capture_imageA()</a>, <a class="el" href="pb__common_8h.html#c7898e44078e2921752734f03e8b59a7">pb_capture_imageW()</a>}<br>
</li><li>pb_capture_raw_image {<a class="el" href="pb__common_8h.html#c7b212b7f6d2405a7f7a6cd2d735ca35" title="Capture a raw image.">pb_capture_raw_imageA()</a>, <a class="el" href="pb__common_8h.html#dff5b1a1b9bcdca34d547795a7a1ed64">pb_capture_raw_imageW()</a>}<br>
</li><li>pb_list_readers {<a class="el" href="pb__common_8h.html#7830f5e5237d7624777975f4d7025e2b" title="Lists available readers.">pb_list_readersA()</a>, <a class="el" href="pb__common_8h.html#3eec9d407857b45f679408ae41e89973">pb_list_readersW()</a>}<br>
</li><li>pb_wait_for_no_finger {<a class="el" href="pb__common_8h.html#ffa3796efc51c08da8b72b6e79356ed7" title="Captures images from the sensor until an empty image is received.">pb_wait_for_no_fingerA()</a>, <a class="el" href="pb__common_8h.html#15a117241d98249f91523f983694978c">pb_wait_for_no_fingerW()</a>}<br>
</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Smart Card Functions</b></dt><dd>A couple of reader specific operations are implemented in two variants. The functionality in these functions are equivalent but the way the reader is identified varies. Normally a reader is identified with it's friendly name. This way of identifying the reader might not work if the user has opened a private session to a smart card in the reader. The way to identify the reader in such cases is with the previously opened SCARDHANDLE. Smart card functions in the toolkit are given 'pb_sc_' as prefix instead of the ordinary 'pb_' prefix. <br>
 The following functions are defined in the toolkit. <br>
<ul>
<li><a class="el" href="pb__common_8h.html#c3866df20ad1dd9684b47bdc8067fc51">pb_sc_cancel()</a><br>
</li><li><a class="el" href="pb__common_8h.html#c5603df153da35996be585f8580075df" title="Captures an image from the sensor.">pb_sc_capture_image()</a><br>
</li><li><a class="el" href="pb__common_8h.html#974b05a59e48fb0c8ed728be1d2816bd">pb_sc_capture_raw_image()</a><br>
</li><li><a class="el" href="pb__common_8h.html#81b6d96ac408ac0d118417c36a19c7a5">pb_sc_wait_for_no_finger()</a><br>
 </li></ul>
</dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="17b2e1c72f87d0b57dfe84de3a856825"></a><!-- doxytag: member="pb_common.h::PBCALL" ref="17b2e1c72f87d0b57dfe84de3a856825" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBCALL&nbsp;&nbsp;&nbsp;__cdecl          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exported functions follow the __cdecl calling convention. 
</div>
</div><p>
<a class="anchor" name="115a9d387670c249cc134d22d225dbb7"></a><!-- doxytag: member="pb_common.h::PB_TRUE" ref="115a9d387670c249cc134d22d225dbb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_TRUE&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True 
</div>
</div><p>
<a class="anchor" name="fab6fc2e90af58fd9df23e12fdb4b640"></a><!-- doxytag: member="pb_common.h::PB_FALSE" ref="fab6fc2e90af58fd9df23e12fdb4b640" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FALSE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False 
</div>
</div><p>
<a class="anchor" name="d952846bfb2a9bcd925fd6eefd3737b7"></a><!-- doxytag: member="pb_common.h::PB_EOK" ref="d952846bfb2a9bcd925fd6eefd3737b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EOK&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returned without errors. 
</div>
</div><p>
<a class="anchor" name="b212572ab6ebcc185e14764fa7d64dd4"></a><!-- doxytag: member="pb_common.h::PB_EBUFFER" ref="b212572ab6ebcc185e14764fa7d64dd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EBUFFER&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
At least one buffer has an incorrect size. 
</div>
</div><p>
<a class="anchor" name="7566dec37a9f5c70483592e814fbc4ea"></a><!-- doxytag: member="pb_common.h::PB_ECANCEL" ref="7566dec37a9f5c70483592e814fbc4ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_ECANCEL&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returned because the caller canceled it. 
</div>
</div><p>
<a class="anchor" name="066b0661e64e00ca77b4ae6ca7eeadd6"></a><!-- doxytag: member="pb_common.h::PB_EFATAL" ref="066b0661e64e00ca77b4ae6ca7eeadd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EFATAL&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An undefined fatal error has occurred. This error code is used for errors that "cannot happen" and isn't covered by any other error code. 
</div>
</div><p>
<a class="anchor" name="501dfccee6304850eeb194621ffea6e6"></a><!-- doxytag: member="pb_common.h::PB_EBIR" ref="501dfccee6304850eeb194621ffea6e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EBIR&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The BIR is corrupt or not recognized as a BIR of the correct type. 
</div>
</div><p>
<a class="anchor" name="4f864119ceaf4796f9ee9ca43f176601"></a><!-- doxytag: member="pb_common.h::PB_EDATA" ref="4f864119ceaf4796f9ee9ca43f176601" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EDATA&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The data passed to the function is not of the correct format. 
</div>
</div><p>
<a class="anchor" name="e2c7b90d6994d411b0f501928817a58a"></a><!-- doxytag: member="pb_common.h::PB_EREADER" ref="e2c7b90d6994d411b0f501928817a58a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EREADER&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The reader name does not represent any connected reader. 
</div>
</div><p>
<a class="anchor" name="66398a36467839143f4641720614d305"></a><!-- doxytag: member="pb_common.h::PB_EMEMORY" ref="66398a36467839143f4641720614d305" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EMEMORY&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cannot allocate enough memory. 
</div>
</div><p>
<a class="anchor" name="edcc9a352cbc3750acf722748bda85f7"></a><!-- doxytag: member="pb_common.h::PB_EINIT" ref="edcc9a352cbc3750acf722748bda85f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EINIT&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function is called before the interface being initialized. 
</div>
</div><p>
<a class="anchor" name="67744d9b2058094c0b99c1c30ad81224"></a><!-- doxytag: member="pb_common.h::PB_ESUPPORT" ref="67744d9b2058094c0b99c1c30ad81224" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_ESUPPORT&nbsp;&nbsp;&nbsp;13          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The requested operation is not supported by the implementation. 
</div>
</div><p>
<a class="anchor" name="ad7732a17769ec4249938dcd04708274"></a><!-- doxytag: member="pb_common.h::PB_EPARAMETER" ref="ad7732a17769ec4249938dcd04708274" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EPARAMETER&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
At least one of the parameters is invalid. 
</div>
</div><p>
<a class="anchor" name="7e34dce8bbe7a4371cb2fbb3fd41aec1"></a><!-- doxytag: member="pb_common.h::PB_EBUSY" ref="7e34dce8bbe7a4371cb2fbb3fd41aec1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EBUSY&nbsp;&nbsp;&nbsp;15          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The reader is already in use. 
</div>
</div><p>
<a class="anchor" name="9d51c1f205c9023bf1a1eb7067188567"></a><!-- doxytag: member="pb_common.h::PB_ETIMEOUT" ref="9d51c1f205c9023bf1a1eb7067188567" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_ETIMEOUT&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The operation timed-out before it could finish the operation. 
</div>
</div><p>
<a class="anchor" name="2e709718f80fa55c00ec2155ed631859"></a><!-- doxytag: member="pb_common.h::PB_EQUALITY" ref="2e709718f80fa55c00ec2155ed631859" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_EQUALITY&nbsp;&nbsp;&nbsp;23          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The fingerprint image is of too poor quality. 
</div>
</div><p>
<a class="anchor" name="2f7b5110e4921f8057d6192a6b6b2613"></a><!-- doxytag: member="pb_common.h::PB_STATUS_OK" ref="2f7b5110e4921f8057d6192a6b6b2613" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_OK&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The quality of the fingerprint is good. 
</div>
</div><p>
<a class="anchor" name="ed3c38285f5c4dbdf101adef5d901581"></a><!-- doxytag: member="pb_common.h::PB_STATUS_TOO_WET" ref="ed3c38285f5c4dbdf101adef5d901581" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_TOO_WET&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The finger is to wet and/or the finger is pressed to hard on the sensor. 
</div>
</div><p>
<a class="anchor" name="f395839c91614d309857d66537dedf0d"></a><!-- doxytag: member="pb_common.h::PB_STATUS_TOO_DRY" ref="f395839c91614d309857d66537dedf0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_TOO_DRY&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The finger is too dry and/or the finger is placed to gently on the sensor. 
</div>
</div><p>
<a class="anchor" name="a655808ea246de90c59ef7e04b6e133d"></a><!-- doxytag: member="pb_common.h::PB_STATUS_TOO_SMALL" ref="a655808ea246de90c59ef7e04b6e133d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_TOO_SMALL&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The captured fingerprint area is too small to do any operations. 
</div>
</div><p>
<a class="anchor" name="2b2a852753ed220a95a4e8d70d539a93"></a><!-- doxytag: member="pb_common.h::PB_STATUS_BAD_FINGER" ref="2b2a852753ed220a95a4e8d70d539a93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_BAD_FINGER&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The captured fingerprint image is of too bad quality to do any biometric operations. The cause of this could be a very worn or dirty finger. 
</div>
</div><p>
<a class="anchor" name="6f33200f731b85611cf906f4c811d5ca"></a><!-- doxytag: member="pb_common.h::PB_STATUS_UNKNOWN" ref="6f33200f731b85611cf906f4c811d5ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_STATUS_UNKNOWN&nbsp;&nbsp;&nbsp;-1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The status of the finger is unknown alt. there is no finger in the image. 
</div>
</div><p>
<a class="anchor" name="13590af28d5f33b68b9e60fd97ae28b3"></a><!-- doxytag: member="pb_common.h::PB_TIMEOUT_FOREVER" ref="13590af28d5f33b68b9e60fd97ae28b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_TIMEOUT_FOREVER&nbsp;&nbsp;&nbsp;UINT_MAX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pre-defined value to never let a function timeout (UINT_MAX == 0xffffffff) 
</div>
</div><p>
<a class="anchor" name="6a9705a7628f1c867fbf60dc483492d1"></a><!-- doxytag: member="pb_common.h::PB_FAR_100" ref="6a9705a7628f1c867fbf60dc483492d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FAR_100&nbsp;&nbsp;&nbsp;(0x7fffffff/100)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False Acceptance Rate 1:100 
</div>
</div><p>
<a class="anchor" name="6bebb8244e3f6758f210f70161dc6e77"></a><!-- doxytag: member="pb_common.h::PB_FAR_1000" ref="6bebb8244e3f6758f210f70161dc6e77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FAR_1000&nbsp;&nbsp;&nbsp;(0x7fffffff/1000)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False Acceptance Rate 1:1000 
</div>
</div><p>
<a class="anchor" name="3b16705f626af76456af024ead76756b"></a><!-- doxytag: member="pb_common.h::PB_FAR_10000" ref="3b16705f626af76456af024ead76756b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FAR_10000&nbsp;&nbsp;&nbsp;(0x7fffffff/10000)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False Acceptance Rate 1:10000 
</div>
</div><p>
<a class="anchor" name="2357e0f22f592e016aafaaf1e697e3d9"></a><!-- doxytag: member="pb_common.h::PB_FAR_100000" ref="2357e0f22f592e016aafaaf1e697e3d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FAR_100000&nbsp;&nbsp;&nbsp;(0x7fffffff/100000)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False Acceptance Rate 1:100000 
</div>
</div><p>
<a class="anchor" name="333ae62a4f294ce8ff6c9aeb583af1ba"></a><!-- doxytag: member="pb_common.h::PB_FAR_1000000" ref="333ae62a4f294ce8ff6c9aeb583af1ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FAR_1000000&nbsp;&nbsp;&nbsp;(0x7fffffff/1000000)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
False Acceptance Rate 1:1000000 
</div>
</div><p>
<a class="anchor" name="9d84d45c3776b3e773851ba8304d503f"></a><!-- doxytag: member="pb_common.h::PB_ENCODING_8_BIT_GRAYSCALE" ref="9d84d45c3776b3e773851ba8304d503f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_ENCODING_8_BIT_GRAYSCALE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
8 bit grayscale image. 0 = black, 255 = white. 
</div>
</div><p>
<a class="anchor" name="b025dd4142d15984442cb2d572bdef60"></a><!-- doxytag: member="pb_common.h::PB_FINGER_UNKNOWN" ref="b025dd4142d15984442cb2d572bdef60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_UNKNOWN&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unknown finger. 
</div>
</div><p>
<a class="anchor" name="7f5e91b44fcfbdb753151cbda383671e"></a><!-- doxytag: member="pb_common.h::PB_FINGER_RIGHT_THUMB" ref="7f5e91b44fcfbdb753151cbda383671e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_RIGHT_THUMB&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right thumb. 
</div>
</div><p>
<a class="anchor" name="c3ded29cdafd0eda7e13a55c3accca58"></a><!-- doxytag: member="pb_common.h::PB_FINGER_RIGHT_INDEX" ref="c3ded29cdafd0eda7e13a55c3accca58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_RIGHT_INDEX&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right index finger. 
</div>
</div><p>
<a class="anchor" name="93b64306a81efbd62a6136bf867ef9a2"></a><!-- doxytag: member="pb_common.h::PB_FINGER_RIGHT_MIDDLE" ref="93b64306a81efbd62a6136bf867ef9a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_RIGHT_MIDDLE&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right ring finger. 
</div>
</div><p>
<a class="anchor" name="5f5ec85db03a813a9d27850094982bc1"></a><!-- doxytag: member="pb_common.h::PB_FINGER_RIGHT_RING" ref="5f5ec85db03a813a9d27850094982bc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_RIGHT_RING&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right little finger. 
</div>
</div><p>
<a class="anchor" name="d3f2b32c73315f92fbfa129512d64ade"></a><!-- doxytag: member="pb_common.h::PB_FINGER_RIGHT_LITTLE" ref="d3f2b32c73315f92fbfa129512d64ade" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_RIGHT_LITTLE&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left thumb. 
</div>
</div><p>
<a class="anchor" name="2ccbb4dfed470ddd1ae8909fe01d3916"></a><!-- doxytag: member="pb_common.h::PB_FINGER_LEFT_THUMB" ref="2ccbb4dfed470ddd1ae8909fe01d3916" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_LEFT_THUMB&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left index finger. 
</div>
</div><p>
<a class="anchor" name="e78a747f9cd2d267218fc1f17cb2751d"></a><!-- doxytag: member="pb_common.h::PB_FINGER_LEFT_INDEX" ref="e78a747f9cd2d267218fc1f17cb2751d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_LEFT_INDEX&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left middle finger. 
</div>
</div><p>
<a class="anchor" name="f2483011c6318a9bbd63c4f9d4336b43"></a><!-- doxytag: member="pb_common.h::PB_FINGER_LEFT_MIDDLE" ref="f2483011c6318a9bbd63c4f9d4336b43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_LEFT_MIDDLE&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left ring finger. 
</div>
</div><p>
<a class="anchor" name="99830e22d52d09cb6004607e168d38b4"></a><!-- doxytag: member="pb_common.h::PB_FINGER_LEFT_RING" ref="99830e22d52d09cb6004607e168d38b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_LEFT_RING&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left ring finger. 
</div>
</div><p>
<a class="anchor" name="67c840ec2cdeb13d6103f7a9f8445353"></a><!-- doxytag: member="pb_common.h::PB_FINGER_LEFT_LITTLE" ref="67c840ec2cdeb13d6103f7a9f8445353" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_FINGER_LEFT_LITTLE&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left little finger. 
</div>
</div><p>
<a class="anchor" name="a6c8c689a4e58d792692d42e7c8ddb9a"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UNKNOWN" ref="a6c8c689a4e58d792692d42e7c8ddb9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UNKNOWN&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unknown sensor / generic image 
</div>
</div><p>
<a class="anchor" name="d1c222564233aa6e49dba5138f08d353"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_AUTHENTEC_AES2501" ref="d1c222564233aa6e49dba5138f08d353" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_AUTHENTEC_AES2501&nbsp;&nbsp;&nbsp;17          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Authentec AES2501 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="4eea749e7271b755e65813e5214785c6"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_AUTHENTEC_AES2550" ref="4eea749e7271b755e65813e5214785c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_AUTHENTEC_AES2550&nbsp;&nbsp;&nbsp;24          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Authentec AES2550 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="5f7e9172331ba64ba1ffd5505e1e2ba0"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_AUTHENTEC_AES2810" ref="5f7e9172331ba64ba1ffd5505e1e2ba0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_AUTHENTEC_AES2810&nbsp;&nbsp;&nbsp;25          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Authentec AES2810 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="a0748e14a227a84f315d4800e506d1e2"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UPEK_TCS1" ref="a0748e14a227a84f315d4800e506d1e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UPEK_TCS1&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UPEK TCS1 area sensor (used in Precise 250 MC) 
</div>
</div><p>
<a class="anchor" name="6f983921c89a34a2862115a0fd35643f"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UPEK_TCS2" ref="6f983921c89a34a2862115a0fd35643f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UPEK_TCS2&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UPEK TCS2 area sensor (used in Precise 200 MC) 
</div>
</div><p>
<a class="anchor" name="fe797370d55152a40acbe5aec5b80935"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UPEK_TCS3" ref="fe797370d55152a40acbe5aec5b80935" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UPEK_TCS3&nbsp;&nbsp;&nbsp;21          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UPEK TCS3 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="0479654ddb318184dfbcd2c3366f022a"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UPEK_TCS4" ref="0479654ddb318184dfbcd2c3366f022a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UPEK_TCS4&nbsp;&nbsp;&nbsp;22          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UPEK TCS4 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="b81bc3300fcea140469394cd36cbbf09"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_UPEK_TCS5" ref="b81bc3300fcea140469394cd36cbbf09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_UPEK_TCS5&nbsp;&nbsp;&nbsp;26          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UPEK TCS5 swipe sensor. 
</div>
</div><p>
<a class="anchor" name="dd05b9057622a2159add9a7e37934714"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_CROSSMATCH_300LC" ref="dd05b9057622a2159add9a7e37934714" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_CROSSMATCH_300LC&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Crossmatch 300 LC 
</div>
</div><p>
<a class="anchor" name="8b07407da7f8bd5fa163bd1f717a2d1e"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_PRECISE_100XS" ref="8b07407da7f8bd5fa163bd1f717a2d1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_PRECISE_100XS&nbsp;&nbsp;&nbsp;17          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Precise Biometrics 100 XS 
</div>
</div><p>
<a class="anchor" name="04ad006b7a966220cb270263d31031e8"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_PRECISE_200MC" ref="04ad006b7a966220cb270263d31031e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_PRECISE_200MC&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Precise Biometrics 200 MC 
</div>
</div><p>
<a class="anchor" name="8f2ba0f004a6ee5ef2dbcfe9d4f347c7"></a><!-- doxytag: member="pb_common.h::PB_SENSOR_PRECISE_250MC" ref="8f2ba0f004a6ee5ef2dbcfe9d4f347c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_SENSOR_PRECISE_250MC&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Precise Biometrics 250 MC 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="9bb29114ecef59668af1dcad6f1f2d89"></a><!-- doxytag: member="pb_common.h::pb_cb_t" ref="9bb29114ecef59668af1dcad6f1f2d89" args=")(int, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
BioMatch callback definition. 
<p>
This function is to be implemented by developers wishing to utilize the callback functionality supported by the toolkit. The callback is called at suitable occasions during the current operation. For area type readers, it will typically be called each time a new image is read from the sensor, but an application must not assume that the reader captures images in a stream. For example, some sensors do not return an image unless there is a finger present on the sensor, and stripe sensors only capture exactly one image of the finger. The application may however assume that the callback will return immediately with an image when a verification/enrollment/capture function is called, so that it does not need to write out finger status information etc. before it calls the function (but it may then take an arbitrarily long time before the callback is called the next time). For readers that don't return a stream of images, this first image will probably be an empty image. The callback will be executed in the same context as the caller (this permit the caller to use thread local storage etc. It also makes it much safer for platforms where a non-threaded application may call a threaded library.) The 'pb_cb_' functions are the only 'pb_'-functions that are guaranteed to work when called from the callback. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>token</em>&nbsp;</td><td>Token provided by the toolkit. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>This parameter is the same as the caller passed to the original operation. It is completely up to the implementation to use it as it sees fit. <div class="fragment"><pre class="fragment"><span class="comment">// example of a callback that checks if a finger is placed on the sensor</span>
<span class="keywordtype">void</span> pb_callback(<span class="keywordtype">int</span> token, <span class="keywordtype">void</span>* context)
{
    <span class="keywordtype">int</span> ret, present;
    ret = pb_cb_finger_status(token, NULL, NULL, NULL, NULL, &amp;present)
    if (ret != <a class="code" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a>)
        return;
    if(!present)
        printf("place finger on reader...");
}
</pre></div> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="abd25f630b7f7afce0c952e8e2014c25"></a><!-- doxytag: member="pb_common.h::pb_cb_cancel" ref="abd25f630b7f7afce0c952e8e2014c25" args="(int token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_cb_cancel           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>token</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels an on-going operation from within an image callback. 
<p>
The cancelled operation will return with the error code <a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a>, and the cancel state is cleared when <a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a> is returned. It is only the functions that have a timeout parameter that are cancelable; other functions are unaffected. The function returns <a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a> even if there are no active operations. The function will not wait for the operation to cancel (this is so that it may be called from callbacks without causing a deadlock.) An application may however not assume that this call returns before the cancelled function returns. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>token</em>&nbsp;</td><td>Token received from callback. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97fa4ba22ab346635ca0d8187b828fc4"></a><!-- doxytag: member="pb_common.h::pb_cb_finger_status" ref="97fa4ba22ab346635ca0d8187b828fc4" args="(int token, pb_image_t **image, int *quality, int *condition, int *present)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_cb_finger_status           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>present</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides "live" information about finger on the sensor. 
<p>
This function is called from within a callback function to retrieve information about the finger currently on the sensor or to retrieve the actual image itself. All parameters in this function are optional. As some parameters require comlpex processing it is recommended only to retrieve the information that is required in the set context. Parameters that aren't required shall be set to NULL. The image data needs to be freed with <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>token</em>&nbsp;</td><td>Token provided by the toolkit. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[image]</em>&nbsp;</td><td>pointer to an <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[quality]</em>&nbsp;</td><td>A measure of the <a class="el" href="pb__common_8h.html#quality">quality</a> of the image. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[condition]</em>&nbsp;</td><td>The <a class="el" href="pb__common_8h.html#condition">condition</a> of the finger. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[present]</em>&nbsp;</td><td>Returns <a class="el" href="pb__common_8h.html#115a9d387670c249cc134d22d225dbb7">PB_TRUE</a> if there is a finger present in the image, and <a class="el" href="pb__common_8h.html#fab6fc2e90af58fd9df23e12fdb4b640">PB_FALSE</a> otherwise. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="feca05cec126da90f3dd2b2cea798801"></a><!-- doxytag: member="pb_common.h::pb_cb_get_image_for_viewing" ref="feca05cec126da90f3dd2b2cea798801" args="(int token, unsigned int size_X, unsigned int size_Y, unsigned int stride_X, unsigned char **image_data, unsigned int *image_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_cb_get_image_for_viewing           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stride_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>image_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>image_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a grayscale image that is suitable for use as user feedback on finger placement. 
<p>
Creates an image of the fingerprint that is suitable for display on screen. The image is returned as an array of data with the specified size and stride. This image is processed for vieweing purposes and should never be used for enrolment or verification. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>token</em>&nbsp;</td><td>Token received from callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_X</em>&nbsp;</td><td>Target image width in pixels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_Y</em>&nbsp;</td><td>Target image height in pixels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stride_X</em>&nbsp;</td><td>Allocated bytes per image row. This value is always larger or equel to size_X. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image_data</em>&nbsp;</td><td>Array of data containing the newly constructed image. This data needs to be freed with <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image_size</em>&nbsp;</td><td>The length of the newly allocated array of image data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When constructing images for display on Windows platform stride_X should be equal to size_X rounded up to the nearest value so that stride_X mod 4 = 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5cec678c539fa81f0e880a07559c342"></a><!-- doxytag: member="pb_common.h::pb_free" ref="c5cec678c539fa81f0e880a07559c342" args="(void *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees allocated memory. 
<p>
Frees memory that has been allocated by the framework, such as the data returned from pb_list_readers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Pointer to the memory to be freed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d09e1938d16493143f911fd706c1e87"></a><!-- doxytag: member="pb_common.h::pb_free_image" ref="8d09e1938d16493143f911fd706c1e87" args="(pb_image_t *image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_free_image           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees allocated memory. 
<p>
Frees memory of an image that has been allocated by the framework, such as the data returned from pb_capture_image. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to the <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> structure to be freed. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76a6bb3424d9fd339503d679306ed7f0"></a><!-- doxytag: member="pb_common.h::pb_initialize" ref="76a6bb3424d9fd339503d679306ed7f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_initialize           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the BioMatch framework. 
<p>
This is function need to be called once prior to any other calls. Calling this function may take a couple of seconds depending on the number of supported readers that need to be enumerated and initialized. It is recommended to call this function only once on application startup. The framework is closed by calling <a class="el" href="pb__common_8h.html#b85a0f6c194614aa46760d0120858301" title="Closes the BioMatch framework.">pb_release()</a>. <dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PB_ETRIAL</em>&nbsp;</td><td>if trial validation was not successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b85a0f6c194614aa46760d0120858301"></a><!-- doxytag: member="pb_common.h::pb_release" ref="b85a0f6c194614aa46760d0120858301" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_release           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes the BioMatch framework. 
<p>
Closes the BioMatch framework and releases resources allocated by a previous call to <a class="el" href="pb__common_8h.html#76a6bb3424d9fd339503d679306ed7f0" title="Initializes the BioMatch framework.">pb_initialize()</a>. <dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7830f5e5237d7624777975f4d7025e2b"></a><!-- doxytag: member="pb_common.h::pb_list_readersA" ref="7830f5e5237d7624777975f4d7025e2b" args="(LPSTR *reader_list, int *nof_readers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_list_readersA           </td>
          <td>(</td>
          <td class="paramtype">LPSTR *&nbsp;</td>
          <td class="paramname"> <em>reader_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nof_readers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lists available readers. 
<p>
Lists the currently conneced readers and returns the list as a multi-string. The order of the readers in the array is arbitrary but consistent, i.e. the relative position of the readers in the list is the same between calls (this means that an application that displays the readers may write them out in order, without risking that the readers "jump around" in the list.) The order may change if the application is shut down and restarted between calls. A reader that currently is used by another process can be listed with a different name. If there are no readers available, the reader list will be NULL. (i.e. no empty structure will be allocated). The reader list needs to be freed by a call to <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>reader_list</em>&nbsp;</td><td>Multi-string of readers. A double NULL terminates the list of values. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nof_readers</em>&nbsp;</td><td>The number of found readers. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#7830f5e5237d7624777975f4d7025e2b" title="Lists available readers.">pb_list_readersA()</a> and as a UNICODE implementation <a class="el" href="pb__common_8h.html#3eec9d407857b45f679408ae41e89973">pb_list_readersW()</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_list_readers. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3eec9d407857b45f679408ae41e89973"></a><!-- doxytag: member="pb_common.h::pb_list_readersW" ref="3eec9d407857b45f679408ae41e89973" args="(LPWSTR *reader_list, int *nof_readers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_list_readersW           </td>
          <td>(</td>
          <td class="paramtype">LPWSTR *&nbsp;</td>
          <td class="paramname"> <em>reader_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nof_readers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lists available readers. <p>
Lists the currently conneced readers and returns the list as a multi-string. The order of the readers in the array is arbitrary but consistent, i.e. the relative position of the readers in the list is the same between calls (this means that an application that displays the readers may write them out in order, without risking that the readers "jump around" in the list.) The order may change if the application is shut down and restarted between calls. A reader that currently is used by another process can be listed with a different name. If there are no readers available, the reader list will be NULL. (i.e. no empty structure will be allocated). The reader list needs to be freed by a call to <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>reader_list</em>&nbsp;</td><td>Multi-string of readers. A double NULL terminates the list of values. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nof_readers</em>&nbsp;</td><td>The number of found readers. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#7830f5e5237d7624777975f4d7025e2b" title="Lists available readers.">pb_list_readersA()</a> and as a UNICODE implementation <a class="el" href="pb__common_8h.html#3eec9d407857b45f679408ae41e89973">pb_list_readersW()</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_list_readers. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="6ca5614c5183cf8c8a37285e4ad17879"></a><!-- doxytag: member="pb_common.h::pb_capture_imageA" ref="6ca5614c5183cf8c8a37285e4ad17879" args="(const LPSTR reader, unsigned int timeout, pb_image_t **image, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_capture_imageA           </td>
          <td>(</td>
          <td class="paramtype">const LPSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures an image from the sensor. 
<p>
This function waits for the fingerprint image to stabilize and achieve sufficient quality before returning. The image data needs to be freed by a call to <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The final image from the reader. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#6ca5614c5183cf8c8a37285e4ad17879" title="Captures an image from the sensor.">pb_capture_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#c7898e44078e2921752734f03e8b59a7">pb_capture_imageW()</a> and as <a class="el" href="pb__common_8h.html#c5603df153da35996be585f8580075df" title="Captures an image from the sensor.">pb_sc_capture_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_capture_image. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7898e44078e2921752734f03e8b59a7"></a><!-- doxytag: member="pb_common.h::pb_capture_imageW" ref="c7898e44078e2921752734f03e8b59a7" args="(const LPWSTR reader, unsigned int timeout, pb_image_t **image, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_capture_imageW           </td>
          <td>(</td>
          <td class="paramtype">const LPWSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures an image from the sensor. <p>
This function waits for the fingerprint image to stabilize and achieve sufficient quality before returning. The image data needs to be freed by a call to <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The final image from the reader. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#6ca5614c5183cf8c8a37285e4ad17879" title="Captures an image from the sensor.">pb_capture_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#c7898e44078e2921752734f03e8b59a7">pb_capture_imageW()</a> and as <a class="el" href="pb__common_8h.html#c5603df153da35996be585f8580075df" title="Captures an image from the sensor.">pb_sc_capture_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_capture_image. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="ffa3796efc51c08da8b72b6e79356ed7"></a><!-- doxytag: member="pb_common.h::pb_wait_for_no_fingerA" ref="ffa3796efc51c08da8b72b6e79356ed7" args="(const LPSTR reader, unsigned int timeout, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_wait_for_no_fingerA           </td>
          <td>(</td>
          <td class="paramtype">const LPSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures images from the sensor until an empty image is received. 
<p>
This function can be called to ensure that the finger is lifted between operations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#ffa3796efc51c08da8b72b6e79356ed7" title="Captures images from the sensor until an empty image is received.">pb_wait_for_no_fingerA()</a> and as a UNICODE implementation <a class="el" href="pb__common_8h.html#15a117241d98249f91523f983694978c">pb_wait_for_no_fingerW()</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_wait_for_no_finger. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15a117241d98249f91523f983694978c"></a><!-- doxytag: member="pb_common.h::pb_wait_for_no_fingerW" ref="15a117241d98249f91523f983694978c" args="(const LPWSTR reader, unsigned int timeout, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_wait_for_no_fingerW           </td>
          <td>(</td>
          <td class="paramtype">const LPWSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures images from the sensor until an empty image is received. <p>
This function can be called to ensure that the finger is lifted between operations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#ffa3796efc51c08da8b72b6e79356ed7" title="Captures images from the sensor until an empty image is received.">pb_wait_for_no_fingerA()</a> and as a UNICODE implementation <a class="el" href="pb__common_8h.html#15a117241d98249f91523f983694978c">pb_wait_for_no_fingerW()</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_wait_for_no_finger. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="c7b212b7f6d2405a7f7a6cd2d735ca35"></a><!-- doxytag: member="pb_common.h::pb_capture_raw_imageA" ref="c7b212b7f6d2405a7f7a6cd2d735ca35" args="(const LPSTR reader, pb_image_t **image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_capture_raw_imageA           </td>
          <td>(</td>
          <td class="paramtype">const LPSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Capture a raw image. 
<p>
Captures a raw image from the sensor. Unlike pb_capture_image this function return immediately once an image has been captured. This function is mainly used for reader diagnostics. The function should not be used to capture images used for template creation. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The captured image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#c7b212b7f6d2405a7f7a6cd2d735ca35" title="Capture a raw image.">pb_capture_raw_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#dff5b1a1b9bcdca34d547795a7a1ed64">pb_capture_raw_imageW()</a> and as <a class="el" href="pb__common_8h.html#974b05a59e48fb0c8ed728be1d2816bd">pb_sc_capture_raw_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_capture_raw_image. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dff5b1a1b9bcdca34d547795a7a1ed64"></a><!-- doxytag: member="pb_common.h::pb_capture_raw_imageW" ref="dff5b1a1b9bcdca34d547795a7a1ed64" args="(const LPWSTR reader, pb_image_t **image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_capture_raw_imageW           </td>
          <td>(</td>
          <td class="paramtype">const LPWSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Capture a raw image. <p>
Captures a raw image from the sensor. Unlike pb_capture_image this function return immediately once an image has been captured. This function is mainly used for reader diagnostics. The function should not be used to capture images used for template creation. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The captured image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#c7b212b7f6d2405a7f7a6cd2d735ca35" title="Capture a raw image.">pb_capture_raw_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#dff5b1a1b9bcdca34d547795a7a1ed64">pb_capture_raw_imageW()</a> and as <a class="el" href="pb__common_8h.html#974b05a59e48fb0c8ed728be1d2816bd">pb_sc_capture_raw_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_capture_raw_image. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="c5603df153da35996be585f8580075df"></a><!-- doxytag: member="pb_common.h::pb_sc_capture_image" ref="c5603df153da35996be585f8580075df" args="(SCARDHANDLE reader, unsigned int timeout, pb_image_t **image, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_sc_capture_image           </td>
          <td>(</td>
          <td class="paramtype">SCARDHANDLE&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures an image from the sensor. 
<p>
This function waits for the fingerprint image to stabilize and achieve sufficient quality before returning. The image data needs to be freed by a call to <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>Handle to smart card received from previous call to SCardConnect(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The final image from the reader. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#6ca5614c5183cf8c8a37285e4ad17879" title="Captures an image from the sensor.">pb_capture_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#c7898e44078e2921752734f03e8b59a7">pb_capture_imageW()</a> and as <a class="el" href="pb__common_8h.html#c5603df153da35996be585f8580075df" title="Captures an image from the sensor.">pb_sc_capture_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3866df20ad1dd9684b47bdc8067fc51"></a><!-- doxytag: member="pb_common.h::pb_sc_cancel" ref="c3866df20ad1dd9684b47bdc8067fc51" args="(SCARDHANDLE reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_sc_cancel           </td>
          <td>(</td>
          <td class="paramtype">SCARDHANDLE&nbsp;</td>
          <td class="paramname"> <em>reader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels an on-going operation. <p>
The cancelled operation will return with the error code PB_ECANCEL. It is only the functions that have a timeout parameter that are cancelable; other functions are unaffected. The function returns PB_EOK even if there are no active operations. The function will not wait for the operation to cancel. An application may not assume that this call returns before the cancelled function returns. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader that shall cancel it's operation. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_cancel. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="974b05a59e48fb0c8ed728be1d2816bd"></a><!-- doxytag: member="pb_common.h::pb_sc_capture_raw_image" ref="974b05a59e48fb0c8ed728be1d2816bd" args="(SCARDHANDLE reader, pb_image_t **image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_sc_capture_raw_image           </td>
          <td>(</td>
          <td class="paramtype">SCARDHANDLE&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Capture a raw image. <p>
Captures a raw image from the sensor. Unlike pb_capture_image this function return immediately once an image has been captured. This function is mainly used for reader diagnostics. The function should not be used to capture images used for template creation. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The captured image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#c7b212b7f6d2405a7f7a6cd2d735ca35" title="Capture a raw image.">pb_capture_raw_imageA()</a>, as a UNICODE implementation <a class="el" href="pb__common_8h.html#dff5b1a1b9bcdca34d547795a7a1ed64">pb_capture_raw_imageW()</a> and as <a class="el" href="pb__common_8h.html#974b05a59e48fb0c8ed728be1d2816bd">pb_sc_capture_raw_image()</a> that will use a SCARDHANDLE instead of a reader name when specifying the reader to use. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_capture_raw_image. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="81b6d96ac408ac0d118417c36a19c7a5"></a><!-- doxytag: member="pb_common.h::pb_sc_wait_for_no_finger" ref="81b6d96ac408ac0d118417c36a19c7a5" args="(SCARDHANDLE reader, unsigned int timeout, pb_cb_t callback, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_sc_wait_for_no_finger           </td>
          <td>(</td>
          <td class="paramtype">SCARDHANDLE&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89">pb_cb_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures images from the sensor until an empty image is received. <p>
This function can be called to ensure that the finger is lifted between operations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout parameter specifies the timeout for the operation (in ms.). If this timeout is reached, the error <a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a> is returned. If timeout is set to <a class="el" href="pb__common_8h.html#13590af28d5f33b68b9e60fd97ae28b3">PB_TIMEOUT_FOREVER</a> then the function will never time out. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>[callback]</em>&nbsp;</td><td>The callback is called for each image that is read from the sensor, and used to provide feedback to the user during the operation. See <a class="el" href="pb__common_8h.html#9bb29114ecef59668af1dcad6f1f2d89" title="BioMatch callback definition.">pb_cb_t</a> for a detailed description of the image callback mechanism. The user-supplied pointer context is used as a parameter to the callback. This can be used by an application as it sees fit. Both callback and context are optional. However, callback must be specified if context is present. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>[context]</em>&nbsp;</td><td>Pointer to user defined data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="invariant" compact><dt><b>Invariant:</b></dt><dd>This function exists as a ASCII implementation <a class="el" href="pb__common_8h.html#ffa3796efc51c08da8b72b6e79356ed7" title="Captures images from the sensor until an empty image is received.">pb_wait_for_no_fingerA()</a> and as a UNICODE implementation <a class="el" href="pb__common_8h.html#15a117241d98249f91523f983694978c">pb_wait_for_no_fingerW()</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_wait_for_no_finger. </dd></dl>
 
</div>
</div><p>
<a class="anchor" name="664e2c5774e64e4076c368598cf98245"></a><!-- doxytag: member="pb_common.h::pb_finger_status" ref="664e2c5774e64e4076c368598cf98245" args="(const pb_image_t *image, int *quality, int *condition, int *present)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_finger_status           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpb__image__t.html">pb_image_t</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>present</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves information about the finger in an image. 
<p>
Used to retrieve information about a fingerprint image. Most parameters are optional. As some parameters require comlpex processing it is recommended only to retrieve the information that is required in the set context. Parameters that aren't required shall be set to NULL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>Image that the operation works on. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[quality]</em>&nbsp;</td><td>A measure of the <a class="el" href="pb__common_8h.html#quality">quality</a> of the image. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[condition]</em>&nbsp;</td><td>The <a class="el" href="pb__common_8h.html#condition">condition</a> of the finger. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>[present]</em>&nbsp;</td><td>Returns PB_TRUE if there is a finger present in the image, and PB_FALSE otherwise. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#9d51c1f205c9023bf1a1eb7067188567">PB_ETIMEOUT</a></em>&nbsp;</td><td>is returned if an image with sufficient quality has not been captured within the specified time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#7566dec37a9f5c70483592e814fbc4ea">PB_ECANCEL</a></em>&nbsp;</td><td>is returned if the operation has been cancelled by a call to pb_cancel or <a class="el" href="pb__common_8h.html#abd25f630b7f7afce0c952e8e2014c25" title="Cancels an on-going operation from within an image callback.">pb_cb_cancel()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c115c0785490e7c2bf2190f355bbfdaa"></a><!-- doxytag: member="pb_common.h::pb_get_image_for_viewing" ref="c115c0785490e7c2bf2190f355bbfdaa" args="(const pb_image_t *image, unsigned int size_X, unsigned int size_Y, unsigned int stride_X, unsigned char **image_data, unsigned int *image_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_get_image_for_viewing           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpb__image__t.html">pb_image_t</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stride_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>image_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>image_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a grayscale image that is suitable for use as user feedback on finger placement. 
<p>
Creates an image of the fingerprint that is suitable for display on screen. The image is returned as an array of data with the specified size and stride. This image is processed for vieweing purposes and should never be used for enrolment or verification. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The source image. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_X</em>&nbsp;</td><td>Target image widht in pixels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_Y</em>&nbsp;</td><td>Target image height in pixels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stride_X</em>&nbsp;</td><td>Allocated bytes per image row. This value is always larger or equal to size_X. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image_data</em>&nbsp;</td><td>Array of data containing the newly constructed image. This data needs to be freed with <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image_size</em>&nbsp;</td><td>The length of the newly allocated array of image data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When constructing images for display on Windows platform stride_X should be equal to size_X rounded up to the nearest value so that stride_X mod 4 = 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="50211bd821e0c52b4a309690cdfda0bd"></a><!-- doxytag: member="pb_common.h::pb_image_to_bmp_buffer" ref="50211bd821e0c52b4a309690cdfda0bd" args="(const pb_image_t *image, unsigned char **bmp_image_buffer, unsigned int *buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_image_to_bmp_buffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpb__image__t.html">pb_image_t</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>bmp_image_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to a bitmap file format buffer. 
<p>
Used to convert a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to an array of a 8 bit grayscale bitmap file format data. The function provides an array of data that the caller can save on disk as an ordinary .bmp file. Conversion is lossless and the resulting image do not use any kind of compression. The bitmap data needs to be freed with <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The image to convert. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bmp_image_buffer</em>&nbsp;</td><td>Array of bitmap file data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of bmp_image_buffer array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="85649e73a8a8a799b55fda0782f8e71f"></a><!-- doxytag: member="pb_common.h::pb_bmp_buffer_to_image" ref="85649e73a8a8a799b55fda0782f8e71f" args="(const unsigned char *bmp_image_buffer, unsigned int buffer_length, pb_image_t **image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_bmp_buffer_to_image           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>bmp_image_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a bitmap image data stream to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. 
<p>
Used to convert an bitmap image to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. The function currently only supports 8 bit grayscale bitmap file format images coded with the Windows V3 40-byte header. The image data needs to be freed with <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bmp_image_buffer</em>&nbsp;</td><td>Array of bitmap file data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of bitmap buffer data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="738a5f7e7cef6b4596f15c2d16f657f7"></a><!-- doxytag: member="pb_common.h::pb_image_to_wsq_buffer" ref="738a5f7e7cef6b4596f15c2d16f657f7" args="(const pb_image_t *image, unsigned char **wsq_image_buffer, unsigned int *buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_image_to_wsq_buffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpb__image__t.html">pb_image_t</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>wsq_image_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to a wsq file format buffer. 
<p>
Used to convert a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image to wsq buffer with file format data. The function provides an array of data that the caller can save on disk as an ordinary .wsq file. The wsq data needs to be freed with <a class="el" href="pb__common_8h.html#c5cec678c539fa81f0e880a07559c342" title="Frees allocated memory.">pb_free()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>The image to convert. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>wsq_image_buffer</em>&nbsp;</td><td>Array of wsq file data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of wsq_image_buffer array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e98826aa2d9c5a0c98d53623779c3c8"></a><!-- doxytag: member="pb_common.h::pb_wsq_buffer_to_image" ref="3e98826aa2d9c5a0c98d53623779c3c8" args="(const unsigned char *wsq_image_buffer, unsigned int buffer_length, pb_image_t **image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_wsq_buffer_to_image           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>wsq_image_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpb__image__t.html">pb_image_t</a> **&nbsp;</td>
          <td class="paramname"> <em>image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a wsq image data stream to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. 
<p>
Used to convert a wsq image to a <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. The image data needs to be freed with <a class="el" href="pb__common_8h.html#8d09e1938d16493143f911fd706c1e87" title="Frees allocated memory.">pb_free_image()</a> when it is no longer needed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wsq_image_buffer</em>&nbsp;</td><td>Array of wsq file data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of wsq buffer data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>image</em>&nbsp;</td><td>Pointer to <a class="el" href="structpb__image__t.html" title="Precise Biometrics image data type.">pb_image_t</a> image. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="33e96e8226ec65988f381a467d95c418"></a><!-- doxytag: member="pb_common.h::pb_cancelA" ref="33e96e8226ec65988f381a467d95c418" args="(LPSTR reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_cancelA           </td>
          <td>(</td>
          <td class="paramtype">LPSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels an on-going operation. 
<p>
The cancelled operation will return with the error code PB_ECANCEL. It is only the functions that have a timeout parameter that are cancelable; other functions are unaffected. The function returns PB_EOK even if there are no active operations. The function will not wait for the operation to cancel. An application may not assume that this call returns before the cancelled function returns. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader that shall cancel it's operation. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_cancel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3741448b4232e490d8bdad93f8960ada"></a><!-- doxytag: member="pb_common.h::pb_cancelW" ref="3741448b4232e490d8bdad93f8960ada" args="(LPWSTR reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PBCALL pb_cancelW           </td>
          <td>(</td>
          <td class="paramtype">LPWSTR&nbsp;</td>
          <td class="paramname"> <em>reader</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels an on-going operation. <p>
The cancelled operation will return with the error code PB_ECANCEL. It is only the functions that have a timeout parameter that are cancelable; other functions are unaffected. The function returns PB_EOK even if there are no active operations. The function will not wait for the operation to cancel. An application may not assume that this call returns before the cancelled function returns. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader that shall cancel it's operation. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="pb__common_8h.html#d952846bfb2a9bcd925fd6eefd3737b7">PB_EOK</a></em>&nbsp;</td><td>if successful. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Other possible return values are defined in <a class="el" href="pb__common_8h.html#error">error</a> codes. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should not be called directly. Always call the macro version of the function; pb_cancel. </dd></dl>
 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Dec 21 17:15:38 2009 for BioMatch Flex H Toolkit For Windows by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
