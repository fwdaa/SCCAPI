#pragma once
#include "patchlevel.h"

///////////////////////////////////////////////////////////////////////////////
// Освобождение объекта 
///////////////////////////////////////////////////////////////////////////////
class PyDecrementor
{
	// функция освобождения объекта 
	private: void (*pfn__Py_Dealloc)(PyObject*); 

	// конструктор
	public: PyDecrementor(void (*pfn__Py_Dealloc)(PyObject*))
	{
		// сохранить переданные параметры 
		this->pfn__Py_Dealloc = pfn__Py_Dealloc; 
	}
	// оператор вызова 
	public: void operator()(PyObject* op) const
	{
#if (PY_MAJOR_VERSION >= 3)
		// уменьшить счетчик ссылок объекта 
		if (--op->ob_refcnt == 0) (*pfn__Py_Dealloc)(op);
#else 
		Py_DECREF(op);
#endif 
	}
}; 

///////////////////////////////////////////////////////////////////////////////
// Категория ошибок Python
///////////////////////////////////////////////////////////////////////////////
class python_error_category : public trace::error_category<PyObject*>
{
	// конструктор
	public: python_error_category(HMODULE hModule) : pfn__Py_Dealloc(nullptr) 
	{
		// инициализировать переменные 
		pfn_PyUnicode_AsUTF8AndSize = nullptr; pfn_PyString_AsStringAndSize = nullptr;
		pfn_PyUnicode_AsUTF8String  = nullptr; 

		// определить адреса функций 
		(FARPROC&)pfn_PyErr_Occurred			 = GetProcAddress(hModule, "PyErr_Occurred"				); 
		(FARPROC&)pfn_PyErr_Fetch				 = GetProcAddress(hModule, "PyErr_Fetch"	 			); 
		(FARPROC&)pfn_PyErr_Restore				 = GetProcAddress(hModule, "PyErr_Restore"				); 
#if (PY_MAJOR_VERSION >= 3)
		(FARPROC&)pfn__Py_Dealloc				= GetProcAddress(hModule, "_Py_Dealloc"					); 
		(FARPROC&)pfn_PyUnicode_GetSize			= GetProcAddress(hModule, "PyUnicode_GetSize"			); 
		(FARPROC&)pfn_PyUnicode_AsWideChar	 	= GetProcAddress(hModule, "PyUnicode_AsWideChar"		); 
		(FARPROC&)pfn_PyUnicode_AsUTF8AndSize	= GetProcAddress(hModule, "PyUnicode_AsUTF8AndSize"		); 
		(FARPROC&)pfn_PyObject_Unicode			= GetProcAddress(hModule, "PyObject_Str"				); 
#else
		(FARPROC&)pfn_PyString_AsStringAndSize	= GetProcAddress(hModule, "PyString_AsStringAndSize"	); 
		(FARPROC&)pfn_PyUnicode_GetSize			= GetProcAddress(hModule, "PyUnicodeUCS2_GetSize"		); 
		(FARPROC&)pfn_PyUnicode_AsWideChar	 	= GetProcAddress(hModule, "PyUnicodeUCS2_AsWideChar"	); 
		(FARPROC&)pfn_PyUnicode_AsUTF8String	= GetProcAddress(hModule, "PyUnicodeUCS2_AsUTF8String"	); 
		(FARPROC&)pfn_PyObject_Unicode			= GetProcAddress(hModule, "PyObject_Unicode"			); 
#endif 
	}
    // получить сообщение об ошибке
    public: virtual std::string message(PyObject* status) const; 

    // получить дополнительное данные ошибки
    public: void trace(PyObject* type, PyObject* value, PyObject* traceback) const; 

	///////////////////////////////////////////////////////////////////////////////
	// Способ освобожденния объекта 
	///////////////////////////////////////////////////////////////////////////////
	private: void (*pfn__Py_Dealloc)(PyObject* obj); 
	public: class PyDecrementor PyDecrementor() const 
	{
		// способ освобожденния объекта 
		return class PyDecrementor(pfn__Py_Dealloc); 
	}
	///////////////////////////////////////////////////////////////////////////////
	// Управление ошибками 
	///////////////////////////////////////////////////////////////////////////////

	// признак наличия ошибки
	private: PyObject* (*pfn_PyErr_Occurred)(); 
	public: PyObject* PyErr_Occurred() const { return (*pfn_PyErr_Occurred)(); }

    // получить состояние ошибки
	private: void (*pfn_PyErr_Fetch)(PyObject**, PyObject**, PyObject**);
    public: void PyErr_Fetch(PyObject** ptype, PyObject** pvalue, PyObject** ptraceback) const
	{
		// пулучить состояние ошибки
		(*pfn_PyErr_Fetch)(ptype, pvalue, ptraceback); 
	} 
    // установить состояние ошибки
	private: void (*pfn_PyErr_Restore)(PyObject*, PyObject*, PyObject*);
    public: void PyErr_Restore(PyObject* type, PyObject* value, PyObject* traceback) const
	{
		// установить состояние ошибки
		(*pfn_PyErr_Restore)(type, value, traceback); 
	} 
	///////////////////////////////////////////////////////////////////////////////
	// Управление строками (здесь String - это String для Python2 и Unicode для Python3)
	///////////////////////////////////////////////////////////////////////////////
	private: int (*pfn_PyString_AsStringAndSize)(PyObject*, char**, Py_ssize_t*);
	public: std::string PyString_AsUTF8String(PyObject* obj) const; 

	private: const char* (*pfn_PyUnicode_AsUTF8AndSize)(PyObject*, Py_ssize_t*); 
	private: PyObject*   (*pfn_PyUnicode_AsUTF8String )(PyObject*); 
	public: std::string PyUnicode_AsUTF8String(PyObject* obj) const; 

	private: Py_ssize_t (*pfn_PyUnicode_GetSize   )(PyObject*); 
	private: Py_ssize_t (*pfn_PyUnicode_AsWideChar)(PyObject*, wchar_t*, Py_ssize_t); 
	public: std::wstring PyUnicode_AsWideString(PyObject* obj) const; 

	////////////////////////////////////////////////////////////////
	// Строковое представление объекта
	////////////////////////////////////////////////////////////////
	private: PyObject* (*pfn_PyObject_Unicode)(PyObject*); 
	public: std::string  PyObject_AsUTF8String(PyObject* obj) const; 
	public: std::wstring PyObject_AsWideString(PyObject* obj) const;
};

///////////////////////////////////////////////////////////////////////////////
// Описание ошибки Python
///////////////////////////////////////////////////////////////////////////////
class python_error : public trace::error_code<PyObject*>
{
    // конструктор
    public: python_error(const python_error_category& category, PyObject* status) 
        
        // сохранить переданные параметры
        : trace::error_code<PyObject*>(status, category) {}

    // конструктор
    public: python_error(const python_error_category& category) 
        
        // сохранить переданные параметры
        : trace::error_code<PyObject*>(category.PyErr_Occurred(), category) {}

    // символическое описание ошибки
    public: std::string name() const
    {	
        // отформатировать код ошибки
        char str[32]; sprintf_s(str, sizeof(str), "%p", value()); return str; 
	}
}; 
// получить сообщение об ошибке
inline std::string python_error_category::message(PyObject* status) const
{
	// отформатировать код ошибки
    char str[32]; sprintf_s(str, sizeof(str), "%p", status); return str; 
}
// признак наличия ошибки
inline bool is_python_error(const python_error& error) { return error.value() != 0; }

///////////////////////////////////////////////////////////////////////////////
// Исключение Python
///////////////////////////////////////////////////////////////////////////////
class python_exception : public trace::exception<PyObject*>
{	
    // тип базового класса
    private: typedef trace::exception<PyObject*> base_type; 

	// описание исключения Python
	private: PyObject* _type; PyObject* _value; PyObject* _traceback; 

    // конструктор
    public: python_exception(const python_error& error,	const char* szFile, int line)

        // сохранить переданные параметры
        : base_type(error, szFile, line), _type(nullptr), _value(nullptr), _traceback(nullptr)
	{
		// выполнить преобразование типа
		const python_error_category& category = 
			(const python_error_category&)error.category(); 

		// получить описание исключения
		if (value()) category.PyErr_Fetch(&_type, &_value, &_traceback);
	}
    // получить дополнительную информацию об ошибке
    public: virtual void trace() const { if (value()) return; 

		// выполнить преобразование типа
		const python_error_category& category = 
			(const python_error_category&)code().category(); 

		// получить дополнительную информацию об ошибке
		category.trace(_type, _value, _traceback); 
	} 
    // выбросить исключение
    public: virtual void raise() const { trace(); 

		// выполнить преобразование типа
		const python_error_category& category = 
			(const python_error_category&)code().category(); 

		// установить исключение Python
		category.PyErr_Restore(_type, _value, _traceback); throw *this;  
	}
};

///////////////////////////////////////////////////////////////////////////////
// Дополнительные определения трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#define WPP_USER_MSG_GUID (1A453A5C, 07A1, 4652, 88A2, BA51F837D2E4)
#include "TracePython.tmh"
#endif 

///////////////////////////////////////////////////////////////////////////////
// Управление строками Python
///////////////////////////////////////////////////////////////////////////////
inline std::string python_error_category::PyString_AsUTF8String(PyObject* obj) const
{
#if (PY_MAJOR_VERSION >= 3)
	// извлечь строковое содержимое
	return PyUnicode_AsUTF8String(obj); 
#else 
	// инициализировать переменные 
	char* buffer = nullptr; Py_ssize_t length = 0; 
		
	// извлечь строку
	if ((*pfn_PyString_AsStringAndSize)(obj, &buffer, &length) < 0) 
	{ 
		// при ошибке выбросить исключение
		AE_CHECK_PYTHON(*this); 
	}
	// вернуть строку
	return std::string(buffer, length); 
#endif 
} 

inline std::string python_error_category::PyUnicode_AsUTF8String(PyObject* obj) const
{
#if (PY_MAJOR_VERSION >= 3)
	// инициализировать переменные 
	const char* buffer = nullptr; Py_ssize_t length = 0; 
		
	// извлечь строку
	buffer = (*pfn_PyUnicode_AsUTF8AndSize)(obj, &length); 

	// при ошибке выбросить исключение
	if (!buffer) AE_CHECK_PYTHON(*this); 

	// вернуть строку
	return std::string(buffer, length); 
#else 
	// выполнить преобразование кодировки
	PyObject* str = (*pfn_PyUnicode_AsUTF8String)(obj); 
	
	// проверить отсутствие ошибок
	if (!str) { AE_CHECK_PYTHON(*this); } 

	// извлечь строковое содержимое
	std::string value = PyString_AsUTF8String(str); 

	// уменьшить счетчик ссылок объекта
	PyDecrementor().operator()(str); return value; 
#endif 
} 

inline std::wstring python_error_category::PyUnicode_AsWideString(PyObject* obj) const
{
	// определить размер строки
	Py_ssize_t length = (*pfn_PyUnicode_GetSize)(obj); 

	// проверить корректность вызова
	if (length < 0) { AE_CHECK_PYTHON(*this); } std::wstring buffer(length, 0);

	// извлечь строку
	length = (*pfn_PyUnicode_AsWideChar)(obj, &buffer[0], length); 

	// проверить отсутствие ошибок
	if (length < 0) { AE_CHECK_PYTHON(*this); } 

	// вернуть строку
	buffer.resize(length); return buffer; 
} 

////////////////////////////////////////////////////////////////
// Строковое представление объекта Python
////////////////////////////////////////////////////////////////
inline std::string python_error_category::PyObject_AsUTF8String(PyObject* obj) const
{
	// получить строковое содержимое
	PyObject* unicodeObj = (*pfn_PyObject_Unicode)(obj); 
	
	// проверить отсутствие ошибок
	if (!unicodeObj) { AE_CHECK_PYTHON(*this); } 

	// извлечь строковое содержимое
	std::string value = PyUnicode_AsUTF8String(unicodeObj); 

	// уменьшить счетчик ссылок объекта
	PyDecrementor().operator()(unicodeObj); return value; 
}

inline std::wstring python_error_category::PyObject_AsWideString(PyObject* obj) const
{
	// получить строковое содержимое
	PyObject* unicodeObj = (*pfn_PyObject_Unicode)(obj); 
	
	// проверить отсутствие ошибок
	if (!unicodeObj) { AE_CHECK_PYTHON(*this); } 

	// извлечь строковое содержимое
	std::wstring value = PyUnicode_AsWideString(unicodeObj); 

	// уменьшить счетчик ссылок объекта
	PyDecrementor().operator()(unicodeObj); return value; 
}

///////////////////////////////////////////////////////////////////////////////
// Дополнительная информация об ошибке
///////////////////////////////////////////////////////////////////////////////
inline void python_error_category::trace(PyObject* type, PyObject* value, PyObject*) const
{
	// добавить описание типа
	std::wstring message; if (type) try { message = PyObject_AsWideString(type); }

	// проверить отсутствие ошибок
	catch (const std::exception&) {} if (value) 
	try { 
		// получить описание объекта
		std::wstring wstr = PyObject_AsWideString(value); 

		// добавить описание объекта
		if (!message.empty()) message += L" : "; message += wstr;
	}
	// проверить отсутствие ошибок
	catch (const std::exception&) {} 
		
	// вывести описание ошибки
	ATRACE(TRACE_LEVEL_ERROR, "%ls", message.c_str()); 
}

///////////////////////////////////////////////////////////////////////////////
// Добавление способа форматирования
///////////////////////////////////////////////////////////////////////////////
inline void format_python(trace::pprintf print, void* context, int level, va_list& args)
{
#if defined _MSC_VER && _MSC_VER >= 1600 

	// извлечь код ошибки
	const python_error& error = va_arg(args, python_error); 
#else 
	// извлечь категорию ошибки
	const python_error_category* category = 
		(const python_error_category*)va_arg(args, const void*); 
	
	// создать код ошибки
	python_error error(*category, va_arg(args, PyObject*));
#endif 
	// определить имя ошибки
	std::string name = error.name(); 

	// вывести имя ошибки
	(*print)(context, level, "%hs", name.c_str()); 
}
WPP_FORMAT_TABLE_EXTENSION(PYTHON, format_python);

///////////////////////////////////////////////////////////////////////////////
// Сбросить идентификатор служебных сообщений
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#undef WPP_USER_MSG_GUID
#endif 
