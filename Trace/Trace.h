#pragma once

///////////////////////////////////////////////////////////////////////////////
// Трассировка Event Tracing for Windows (ETW)
///////////////////////////////////////////////////////////////////////////////
// Генерация событий в ETW производится провайдерами трассировки (event trace 
// providers). Управление провайдерами трассировки (включающее регистрацию 
// провайдера, отмену регистрации провайдера и генерацию событий) 
// осуществляется из кода приложений, которые генерируют события трассировки. 
// Прием сообщений о событиях в ETW осуществляют сеансы трассировки (event 
// trace sessions). Провайдеры трассировки, в зависимости от своего типа, могут 
// пересылать сообщения как нескольким сеансам трассировки, так и только одному 
// сеансу трассировки. 
// 
// Каждый провайдер трассировки идентифицируется своим GUID. В ETW провайдеры 
// бывают следующих типов: 
// 1) провайдеры Managed Object Format (MOF). Частным случаем MOF-провайдеров 
//    являются провайдеры Windows Preprocessor Software Tracing (WPP);  
// 2) провайдеры, основанные на манифесте;
// 3) провайдеры TraceLogging. 
// Отличие различных типов провайдеров заключается в используемых функциях 
// регистрации, числе сеансов, которые могут принимать сообщения от провайдера,  
// и способом связывания бинарных данных, передаваемых в сообщениях, с 
// подробным описанием событий, хранимых отдельно от сообщений. 
// 
// Управление сеансами трассировки (создание, удаление, изменение параметров) 
// осуществляется (в зависимости от типа сеанса) либо на основании значений 
// системного реестра, либо контроллерами трассировки (trace controllers) -  
// приложениями, функционирующими в пользовательском режиме и использующими 
// специальное API (controller API). 
// 
// Контроллеры трассировки создают сеанс трассировки с использованием функции 
// StartTrace, а завершают сеанс трассировки с использованием функции 
// ControlTrace с передачей ей кода EVENT_TRACE_CONTROL_STOP. Настройка 
// контроллером принимаемых сеансом сообщений производится функцией 
// EnableTrace, а изменение других параметров сеанса - функцией ControlTrace. 
// При вызове контроллером функции EnableTrace об этом уведомляется провайдер 
// трассировки через зарегистрированную функцию обратного вызова. 
// 
// Каждый сеанс трассировки идентифицируется своим GUID, который, как правило, 
// генерируется автоматически. Сеансы трассировки бывают следующих типов: 
// 1) GlobalLogger. Может быть только один сеанс указанного типа c GUID, равным 
//    GlobalLoggerGuid. Сеанс предназначен для приема сообщений, которые не 
//    принимаются другими сеансами. В основном это касается сообщений, 
//    генерируемых драйверами устройств на этапе загрузки операционной системы, 
//    а также сообщений о специальных событиях от ядра операционной системы. 
//    Сеанс запускается при загрузке операционной системы и управляется 
//    параметрами из системного реестра, в котором перечислены допустимые 
//    провайдеры трассировки. Сеанс не оповещает о своем запуске провайдеры 
//    трассировки, перечисленные в реестре; 
// 2) AutoLogger (начиная с Windows Vista). Может быть несколько сеансов 
//    указанного типа. Сеансы запускаются при загрузке операционной системы и   
//    управляются параметрами из системного реестра, в котором перечислены 
//    допустимые провайдеры трассировки. В отличие от сеанса GlobalLogger, 
//    cеансы AutoLogger оповещают о своем запуске перечисленные в реестре 
//    провайдеры трассировки, но не могут принимать сообщения о специальных 
//    событиях от ядра операционной системы; 
// 3) Сеансы системных провайдеров. Cеансы предназначены для приема сообщений 
//    только от ядра операционной системы после ее загрузки и связаны только 
//    с системным провайдером. Сеансы управляются контроллером и не используют 
//    системный реестр. До Windows 8/Windows Server 2012 мог быть только один 
//    сеанс указанного типа, называемый NT Kernel Logger с GUID, равным 
//    SystemTraceControlGuid. Начиная с Windows 8/Windows Server 2012, может 
//    быть до 8 сеасов с системным провайдером, среди которых может быть и 
//    NT Kernel Logger;  
// 4) Event Tracing. Может быть несколько сеансов указанного типа. Сеанс 
//    предназначен для приема сообщений после загрузки операционной системы. 
//    Такими сообщениями могут быть как сообщения от провайдеров трассировки 
//    драйверов устройств, так и сообщения от провайдеров трассировки 
//    пользовательского режима. Сеанс управляется контроллером и не использует 
//    системный реестр. Сеанс оповещает о своем запуске и изменении параметров 
//    требуемые провайдеры трассировки;
// 5) Private Logger. Сеанс предназначен для приема сообщений от провайдеров 
//    трассировки пользовательского режима и может создаваться только в 
//    адресном пространстве процесса указанных провайдеров. Может быть 
//    несколько сеансов указанного типа. Сеанс управляется контроллером и 
//    не использует системный реестр. Сеанс оповещает о своем запуске и 
//    изменении параметров провайдеры трассировки. 
// Общее число сеансов трассировки не может превышать 32 для Windows 2000 и 
// 64 для последующих версий Windows (в это число не включаются сеансы 
// Private Logger). 
// 
// В сеансах трассировки сообщения сохраняются в специальных буферах, которые 
// в определенные моменты времени, в зависимости от режима работы сеанса, 
// могут сбрасываться в файлы на диске или передаваться потребителям 
// трассировки (trace consumers), подключенным к сеансам. Возможно выполнение 
// обоих вариантов, а также варианта, в котором при переполнении буферов новые
// сообщения начинают перезаписывать старые сообщения без их внешнего 
// сохранения и передачи. 
// 
// Потребители трассировки подключаются к сеансам трассировки функцией 
// OpenTrace, а отключаются - функцией CloseTrace. При вызове функции OpenTrace 
// ей передаются функции обратного вызова, вызываемые сеансом для передачи 
// входящих сообщений потребителю. Цикл обработки потребителем сообщений от 
// сеанса инициируется вызовом функции ProcessTrace. 
// 
// Запись сообщений в файлы или передача их потребителям производится сеансом 
// при полном заполнении одного из буферов, при закрытии сеанса и через 
// промежутки времени, задаваемый параметром FlushTimer. Если буферы 
// заполняются быстрее, чем очищаются, то ETW выделяет новые буферы для 
// предотвращения потери сообщений. Начальное число буферов в сеансе 
// определяется параметром MinimumBuffers, максимальное число - параметром 
// MaximumBuffers, а размер каждого буфера - параметром BufferSize. При 
// заполнении максимального числа буферов вновь поступающие сообщения 
// отбрасываются, поэтому в ETW возможна потеря сообщений. 
// 
// С каждым принятым сообщением в буферах сохраняется время его появления. 
// Указанное время может быть одним из следующих: счетчик высокой 
// производительности (query performance counter), системное время (FILETIME) 
// или счетчик циклов процессора (TimeStamp Counter, TSC). Тип используемого 
// времени определяется параметром ClockType. Заметим, что счетчик высокой 
// производительности и счетчик циклов процессора представляют собой 
// относительное время, поэтому в начале трассировки сохраняется системное 
// время, значение которого вместе со значением сохраняемого относительного 
// времени позволяет вычислить абсолютное системное время. 
// 
// Основной режим работы сеанса трассировки, а также его модификации, задается 
// параметром LogFileMode. Указанный параметр предсталяет собой битовую маску, 
// в которой основной режим задают следующие биты (EVENT_TRACE_FILE_MODE_NONE 
// не является битом, а представляет собой нулевое значение, которое 
// используется при отсутствии установки других битов): 
// 1) EVENT_TRACE_BUFFERING_MODE - режим циклической перезаписи старых 
//    сообщений в буфере без их внешнего сохранения. Буфер используется только 
//    один с общим размером, равным MinimumBuffers * BufferSize, а параметр 
//    MaximumBuffers не используется. Бит является взаимоисключающим со всеми 
//    остальными битами;  
// 2) EVENT_TRACE_REAL_TIME_MODE - режим передачи сообщений подключенным 
//    потребителям (т.н. режим реального времени). При отсутствии потребителей
//    сообщения теряются (до Windows Vista) или записываются во временный 
//    файл ограниченного размера (начиная с Windows Vista). В последнем случае 
//    при появлении потребителей им сначала будут переданы сообщения из 
//    временного файла и лишь затем сообщения из накопленных буферов. Указанный 
//    бит можно обьединять с битами 3)-6);  
// 3) EVENT_TRACE_FILE_MODE_NONE - режим последовательной записи в файл, при 
//    котором размер файла не ограничивается. Имя файла задается в параметре 
//    FileName. При наличии файла с указанным именем он будет перезаписан, если 
//    не указан бит EVENT_TRACE_FILE_MODE_APPEND. В последнем случае, записи 
//    будут добавляться в существующий файл;  
// 4) EVENT_TRACE_FILE_MODE_SEQUENTIAL - режим последовательной записи в файл, 
//    при котором запись завершается при достижении файлом максимального 
//    размера. Поступающие сообщения после этого отбрасываются. Имя файла 
//    задается в параметре FileName, а максимальный размер файла - в параметре 
//    MaxFileSize. При наличии файла с указанным именем он будет перезаписан, 
//    если не указан бит EVENT_TRACE_FILE_MODE_APPEND. В последнем случае, 
//    записи будут добавляться в существующий файл; 
// 5) EVENT_TRACE_FILE_MODE_CIRCULAR - режим циклической записи буферов в файл,
//    при котором при достижении файлом максимального размера новые сообщения 
//    будут перезаписывать старые. Имя файла задается в параметре FileName, 
//    а максимальный размер файла - в параметре MaxFileSize. При наличии файла 
//    с указанным именем он будет перезаписан; 
// 6) EVENT_TRACE_FILE_MODE_NEWFILE - режим последовательной записи в файл, при 
//    котором при достижении файлом максимального размера запись выполняется в 
//    новый файл с увеличением номера в имени файла. В данном режиме параметр 
//    FileName cодержит не точное имя файла, а его форматируемое имя (например, 
//    "c:\test%d.etl"). Максимальный размер файла задается в параметре 
//    MaxFileSize; 
// 
// В режимах последовательной записи 3)-4) при добавлении записей в файл 
// необходимо гарантировать, что параметры, влияющие на формат содержимого 
// файла, у сеанса, создавшего файл, совпадают с параметрами сеанса, 
// добавляющего записи в файл. Кроме того, отметка времени сообщения должна 
// быть системным (абсолютным) временем, в противном случае (при использовании 
// относительного времени) невозможно будет вычислить абсолютное время 
// возникновения события. При наличии максимального размера файла в режимах 
// 4)-6) можно также указать бит EVENT_TRACE_FILE_MODE_PREALLOCATE, который 
// заставляет ETW зарезервировать для файла пространство его максимального 
// размера на диске. При завершении сеанса размер файла будет уменьшен до 
// реального.   
// 
// По умолчанию отдельные процессоры выполняют запись сообщений (с отметкой 
// времени) в свой собственный буфер, поэтому при недостаточно точном 
// разрешении времени для сообщений из различных буферов с совпадающей 
// отметкой времени их запись в файлы или передача потребителям может быть 
// выполнена не в том порядке. Указание в параметре LogFileMode флага 
// EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING (начиная с Windows 7) заставляет 
// различные процессоры писать в одни и те же буферы, что позволяет избежать 
// проблему некорректного порядка сообщений, но при этом снижается 
// быстродействие трассировки. 
// 
// По умолчанию буферы трассировки для сеансов GlobalLogger, AutoLogger, 
// системных провайдеров и Event Tracing выделяются из пула невыгружаемой 
// памяти, а для сеансов Private Logger - из пула выгружаемой памяти. Для 
// сеансов типа Event Tracing указанное поведение можно изменить, указав бит 
// EVENT_TRACE_USE_PAGED_MEMORY в параметре LogFileMode. В таком случае, 
// сеансы Event Tracing теряют возможность приема сообщений из режима ядра.  
 
///////////////////////////////////////////////////////////////////////////////
// Провайдеры Managed Object Format
///////////////////////////////////////////////////////////////////////////////
// В пользовательском режиме регистрация MOF-провайдеров трассировки 
// производится функцией RegisterTraceGuids, а отмена регистрации - функцией 
// UnregisterTraceGuids. При регистрации провайдера указывается адрес функции 
// обратного вызова WMIDPREQUEST, которая вызывается при возникновении событий, 
// связанных с провайдером. 
// 
// В режиме ядра до Windows Vista SP1 регистрация и отмена регистрации 
// MOF-провайдеров трассировки в драйверах производится функцией 
// IoWMIRegistrationControl с указанием недокументированных флагов 
// WMIREG_FLAG_CALLBACK и WMIREG_FLAG_TRACE_PROVIDER. Первый флаг указывает, 
// что первым параметром функции IoWMIRegistrationControl будет функция 
// обратного вызова, а не объект драйвера (PDRIVER_OBJECT). Второй параметр
// определяет назначение и прототип функции обратного вызова, которая 
// вызывается при возникновении событий, связанных с провайдером. В данном 
// случае, прототипом функции обратного вызова является
// typedef LONG (*WMIENTRY_NEW)(
//      IN UCHAR MinorFunction,      // код события
//      IN PVOID DataPath OPTIONAL,  // не используется
//      IN ULONG BufferLength,       // размер буфера
//      IN OUT PVOID Buffer,         // буфер входных и выходных данных
//      IN PVOID Context,            // связанный контест 
//      OUT PULONG Size              // размер выходных данных
// );
// Начиная с Windows Vista SP1 в режиме ядра регистрация провайдеров трассировки 
// производится функцией EtwRegisterClassicProvider, а отмена регистрации - 
// функцией EtwUnregister. При регистрации провайдера указывается адрес функции 
// обратного вызова ETW_CLASSIC_CALLBACK, которая вызывается при возникновении 
// событий, связанных с провайдером. 
// 
// Генерация событий в MOF-провайдерах осуществляется функциями TraceEvent 
// (в пользовательском режиме) и IoWMIWriteEvent (в режиме ядра). 
// 
// Кроме того, MOF-провайдеры могут генерировать текстовые сообщения при помощи 
// функций TraceMessageVa/TraceMessage (в пользовательском режиме) и 
// WmiTraceMessageVa/WmiTraceMessage (в режиме ядра). Текстовые сообщения, 
// генерируемые MOF-провайдером, идентифицируются парой (GUID, ID), где GUID - 
// уникальный идентификатор источника сообщения, а ID - идентификатор сообщения 
// в источнике. При генерации текстового сообщения провайдером трассировки с 
// ним можно связать переменное число параметров, передаваемых без указания 
// типа в виде пар (адрес, размер). Кроме того, c каждым текстовым сообщением, 
// переданным MOF-провайдером с опцией TRACE_MESSAGE_SEQUENCE, сеанс должен 
// сопоставить специальный последовательный номер, который будет уникальным 
// для всех сеансов, если в параметре LogFileMode сеанса установлен флаг 
// EVENT_TRACE_USE_GLOBAL_SEQUENCE, или уникальным только в рамках данного 
// сеанса, если установлен флаг EVENT_TRACE_USE_LOCAL_SEQUENCE. Способ поиска 
// сообщения по паре (GUID, ID) выходит за рамки ETW и определяется 
// инструментальными средствами на свое усмотрение. Ниже будет описан такой 
// способ для трассировки WPP. 
// 
///////////////////////////////////////////////////////////////////////////////
// Трассировка Windows Preprocessor Software Tracing (WPP)
///////////////////////////////////////////////////////////////////////////////
// Трассировка WPP основывается на трассировке ETW, в реализации которой 
// уточняются интерпретация параметров EnableFlag и EnableLevel провайдерами 
// трассировки и способ формирование сообщений по (GUID, ID). Кроме того, 
// трассировка WPP позволяет только одному сеансу принимать сообщения от 
// отдельного провайдера трассировки. 
// 
// Каждый провайдер трассировки WPP имеет дружественное имя, GUID и 
// поддерживаемые категории сообщений, каждая из которых имеет собственное 
// имя. Каждое сообщение трассировки, идентифицируемые парой (GUID, ID), 
// содержит следующие компоненты: строку форматирования, описание типов 
// передаваемых параметров, категорию и/или степень важности. 
// 
// В трассировке WPP параметр EnableFlag определяет допустимые категории 
// сообщений, а параметр EnableLevel - допустимую степень важности сообщений.
// Форматирование сообщений по (GUID, ID) происходит следующим образом: 
// 1) по GUID определяется имя TMF-файла описания сообщений источника (в 
//    качестве источника используется отдельный файл исходного кода, в 
//    котором расположены вызовы функций TraceMessageVa и TraceMessage); 
// 2) по ID из TMF-файла извлекаются компоненты сообщения;
// 3) форматирование сообщений определяется на основе строки форматирования, 
//    типов и значений передаваемых параметров по специальными правилам, 
//    которые будут описаны ниже. 
// Кроме того, при трассировке WPP создаются TMC-файлы, которые содержат 
// описания используемых провайдеров трассировки: дружественное имя, GUID и 
// поддерживаемые категории сообщений. TMF-и TMC-файлы позволяют утилите 
// TraceView создавать сеансы трассировки, настраивать допустимые в сеансе
// провайдеры и проводить фильтрацию сообщений по категории и/или степени 
// важности. 
//
// Состояние отдельного провайдера трассировки WPP описывается структурой
// WPP_TRACE_CONTROL_BLOCK, за которой следует дополнительное пространство, 
// используемое в качестве расширения поля Flags (если категорий сообщений 
// больше 32). 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 0, то 
// оставшиеся поля структуры имеют следующее значения: 
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Logger               - описатель сеанса, связанного с провайдером; 
// FlagsLen             - размер буфера Flags в 32-разрядных элементах; 
// Level                - допустимая степень важности сообщений провайдера в сеансе; 
// Flags                - битовая маска допустимых категорий сообщений провайдера в сеансе; 
// ControlGuid          - адрес GUID провайдера. 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_WIN2K_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Win2kCb              - адрес структуры WPP_WIN2K_CONTROL_BLOCK, поля которой имеют следующее значение: 
//      Logger          - описатель сеанса, связанного с провайдером; 
//      Flags           - битовая маска допустимых категорий сообщений провайдера в сеансе; 
//      Level           - допустимая степень важности сообщений провайдера в сеансе; 
//      ControlGuid     - адрес GUID провайдера; 
// FlagsLen             - не используется (отсутствовало в Windows 2000); 
// Level                - не используется (отсутствовало в Windows 2000); 
// Flags                - не используется (отсутствовало в Windows 2000); 
// ControlGuid          - не используется (отсутствовало в Windows 2000). 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_WHISTLER_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Cb                   - адрес структуры WPP_TRACE_CONTROL_BLOCK, поля которой имеют следующее значение: 
//      Next                 - может использоваться на усмотрение провайдера; 
//      UmRegistrationHandle - может использоваться на усмотрение провайдера; 
//      Logger               - описатель сеанса, связанного с провайдером; 
//      FlagsLen             - размер буфера Flags в 32-разрядных элементах; 
//      Level                - допустимая степень важности сообщений провайдера в сеансе; 
//      Flags                - битовая маска допустимых категорий сообщений провайдера в сеансе; 
//      ControlGuid          - адрес GUID провайдера; 
// FlagsLen             - может использоваться на усмотрение провайдера; 
// Level                - может использоваться на усмотрение провайдера; 
// Flags                - может использоваться на усмотрение провайдера; 
// ControlGuid          - адрес GUID провайдера. 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_LH_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Ptr                  - адрес структуры WPP_TRACE_CONTROL_BLOCK, поля которой имеют следующее значение: 
//      Next                 - может использоваться на усмотрение провайдера; 
//      UmRegistrationHandle - может использоваться на усмотрение провайдера; 
//      Logger               - описатель сеанса, связанного с провайдером; 
//      FlagsLen             - может использоваться на усмотрение провайдера; 
//      Level                - может использоваться на усмотрение провайдера; 
//      Flags                - может использоваться на усмотрение провайдера; 
//      ControlGuid          - может использоваться на усмотрение провайдера; 
// FlagsLen             - размер буфера Flags в 32-разрядных элементах; 
// Level                - допустимая степень важности сообщений провайдера в сеансе; 
// Flags                - битовая маска допустимых категорий сообщений провайдера в сеансе; 
// ControlGuid          - адрес GUID провайдера. 
// 
// При использовании WPP трассировка сообщений (событий) производится 
// провайдерами трассировки. Каждый провайдер трассировки имеет дружественное 
// имя, GUID и поддерживаемые категории сообщений, каждая из которых имеет 
// собственное имя. Определение провайдеров трассировки производится внутри 
// макроса WPP_CONTROL_GUIDS с использованием макроса WPP_DEFINE_CONTROL_GUID. 
// Провайдеры трассировки, задействованные в статических библиотеках, 
// необходимо также указывать в макросе WPP_CONTROL_GUIDS исполняемых модулей 
// (.exe, .dll), использующих указанные библиотеки. 
// 
// Параметры, передаваемые макросу WPP_DEFINE_CONTROL_GUID(Name, Guid, Bits), 
// имеют следующий смысл: 
// Name - дружественное имя провайдера трассировки; 
// Guid - GUID провайдера трассировки, передаваемый в виде 
//        (xxxxxxxx,xxxx,xxxx,xxxx,xxxxxxxxxxxx); 
// Bits - имена категорий сообщений, передаваемые в виде 
//        WPP_DEFINE_BIT(Name1) ... WPP_DEFINE_BIT(NameN). 
// 
// Например, определение макроса WPP_CONTROL_GUIDS может выглядеть следующим 
// образом: 
// #define WPP_CONTROL_GUIDS                                \
//      WPP_DEFINE_CONTROL_GUID(                            \
//        Regular, (81b20fea,73a8,4b62,95bc,354477c97a6f),  \
//        WPP_DEFINE_BIT(Error)                             \
//        WPP_DEFINE_BIT(Unusual)                           \
//        WPP_DEFINE_BIT(Noise)                             \
//     )                                                    \
//     WPP_DEFINE_CONTROL_GUID(                             \
//        HiFreq, (91b20fea,73a8,4b62,95bc,354477c97a6f),   \
//        WPP_DEFINE_BIT(Entry)                             \
//        WPP_DEFINE_BIT(Exit)                              \
//        WPP_DEFINE_BIT(ApiCalls)                          \
//        WPP_DEFINE_BIT(RandomJunk)                        \
//        WPP_DEFINE_BIT(LovePoem)                          \
//     )

///////////////////////////////////////////////////////////////////////////////
// Стандартные определения трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined _WIN32
#include <wmistr.h>                     // определения WMI
#include <evntrace.h>                   // определения ETW
#else 
#define TRACE_LEVEL_NONE            0   // отсутствие трассировки
#define TRACE_LEVEL_CRITICAL        1   // критическая ошибка
#define TRACE_LEVEL_ERROR           2   // ошибка
#define TRACE_LEVEL_WARNING         3   // предупреждение
#define TRACE_LEVEL_INFORMATION     4   // информация
#define TRACE_LEVEL_VERBOSE         5   // детализированная информация
#endif 

///////////////////////////////////////////////////////////////////////////////
// Определение имени функции
///////////////////////////////////////////////////////////////////////////////
#if defined _MSC_VER
#define WPP_FUNC            __FUNCSIG__
#else 
#define WPP_FUNC            __func__
#endif 

///////////////////////////////////////////////////////////////////////////////
// Запрет встраивания функций
///////////////////////////////////////////////////////////////////////////////
#if defined _MSC_VER
#define WPP_NOINLINE        __declspec(noinline)
#else 
#define WPP_NOINLINE        __attribute__((noinline)) 
#endif 

///////////////////////////////////////////////////////////////////////////////
// Создание литеральной строки. WPP_STRINGIZE(x) нельзя определить как #x, 
// поскольку при использовании # не производится раскрытия аргумента. Например, 
// в этом случае WPP_STRINGIZE(OTHER_MACRO(x)) перешло бы в "OTHER_MACRO(x)", 
// а не в строковое значение раскрытого OTHER_MACRO(x).
///////////////////////////////////////////////////////////////////////////////
#define WPP_STR(      x)          # x
#define WPP_STRINGIZE(x)    WPP_STR(x)

///////////////////////////////////////////////////////////////////////////////
// Создание уникального имени переменной. WPP_VAR(LINE) нельзя определить как
// Trace ## LINE, поскольку при использовании ## не производится раскрытия 
// аргумента. Например, WPP_VAR(__LINE__) перешло бы в Trace__LINE__, а не в 
// TraceXXX, где XXX - номер строки (результат раскрытия макроса __LINE__)
///////////////////////////////////////////////////////////////////////////////
#define WPP_GLUE(x, y)      x ## y
#define WPP_VAR(LINE )      WPP_GLUE(Trace, LINE)

///////////////////////////////////////////////////////////////////////////////
// Настройка провайдера трассировки. Провайдер трассировки определяется 
// макросом WPP_DEFINE_CONTROL_GUID, который должен присутствовать в 
// определении специального макроса WPP_CONTROL_GUIDS. Параметрами макроса 
// WPP_DEFINE_CONTROL_GUID выступают дружественное имя провайдера, его 
// GUID-идентификатор, а также имена битов, определяющих различные категории 
// трассировки. Поскольку мы используем уровень важности сообщений трассировки, 
// а не их категории, то все сообщения трассировки будем относить к одной и той 
// же категории ALL (бит 0). В определении макроса WPP_CONTROL_GUIDS также 
// следует включить определения провайдеров трассировки, задействованных в 
// используемых статических библиотеках. 
///////////////////////////////////////////////////////////////////////////////
#if !defined WPP_CONTROL_NAME
#error [Trace.h] The WPP_CONTROL_NAME should be defined prior to including Trace.h
#endif

#define ThisDir WPP_CONTROL_NAME

// Строковое представление имени провайдера
#define WPP_COMPNAME WPP_STRINGIZE(WPP_CONTROL_NAME)

// Определение провайдеров для статических библиотек
#if !defined WPP_STATIC_LIB_GUIDS
#define WPP_STATIC_LIB_GUIDS
#endif 

// Определение идентификаторов трассировки
#if defined WPP_CONTROL_GUID
#define WPP_CONTROL_GUIDS                                           \
    WPP_DEFINE_CONTROL_GUID(WPP_CONTROL_NAME, WPP_CONTROL_GUID,     \
        WPP_DEFINE_BIT(ALL)                                         \
    )                                                               \
    WPP_STATIC_LIB_GUIDS
#endif

///////////////////////////////////////////////////////////////////////////////
// Дополнительно используемые файлы
///////////////////////////////////////////////////////////////////////////////
#include <stdarg.h>         // функции с переменным числом аргументов
#include <string.h>         // строковые функции 

///////////////////////////////////////////////////////////////////////////////
// Указание правильного соглашения о вызове функции TraceMessageVa. 
// В некоторых версиях файла evntrace.h stdcall-функция TraceMessageVa 
// объявлена без указания соглашения о вызове, что при использовании 
// компилятором по умолчанию соглашения __cdecl приводит к формированию 
// неправильного декорированного имени функции и нарушению стека при 
// выполнении функции. 
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS && !defined _NTDDK_
#if defined _MSC_VER && !defined _WIN64
#pragma comment(linker, "/alternatename:_TraceMessageVa=_TraceMessageVa@24")

// указать правильный прототип функции
typedef ULONG (WINAPI *PFN_TRACE_MESSAGE_VA)(TRACEHANDLE, ULONG, LPCGUID, USHORT, va_list);

// вызвать функцию трассировки
inline ULONG WINAPI CallTraceMessageVa(TRACEHANDLE LoggerHandle,
    ULONG MessageFlags, LPCGUID MessageGuid, USHORT MessageNumber, va_list MessageArgList)
{
    // выполнить преобразование типа
    PFN_TRACE_MESSAGE_VA pfn = (PFN_TRACE_MESSAGE_VA)::TraceMessageVa; 

    // выполнить трассировку
    return (*pfn)(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, MessageArgList); 
}
#else 
// вызвать функцию трассировки
inline ULONG WINAPI CallTraceMessageVa(TRACEHANDLE LoggerHandle,
    ULONG MessageFlags, LPCGUID MessageGuid, USHORT MessageNumber, va_list MessageArgList)
{
    // выполнить трассировку
    return ::TraceMessageVa(LoggerHandle, MessageFlags, (LPGUID)MessageGuid, MessageNumber, MessageArgList); 
}
#endif 
#endif

///////////////////////////////////////////////////////////////////////////////
// Во избежание дублирования определения компонентов в .tmc-файлах при сборке
// Release-версии необходимо удалять неиспользуемые символы через опцию 
// связывания /OPT:REF. Указание опции в свойствах проекта осуществляется как 
// <OptimizeReferences>true</OptimizeReferences> 
// 
///////////////////////////////////////////////////////////////////////////////
// Для создания .PDB-файлов должен быть установлен параметр /DEBUG 
// компоновщика. В ранних версиях Visual Studio (до 17.0) существовали только 
// варианты /DEBUG и /DEBUG:NONE. Указание их в свойствах проекта 
// осуществлялось как 
// <GenerateDebugInformation>yes</GenerateDebugInformation> и 
// <GenerateDebugInformation>no</GenerateDebugInformation> (при разработке 
// приложений пользовательского режима) и 
// <GenerateDebugInformation>Debug</GenerateDebugInformation> и 
// <GenerateDebugInformation>None</GenerateDebugInformation> (при разработке 
// драйверов режима ядра). 
// В Visual Studio 17.0 появился вариант /DEBUG:FASTLINK, а опция /DEBUG стала 
// называтся /DEBUG:FULL. Тем не менее вариант /DEBUG был оставлен для 
// совместимости и он равносилен указанию /DEBUG:FULL. Опции /DEBUG:FULL 
// и /DEBUG:NONE в свойствах проекта указываются как
// <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
// <GenerateDebugInformation>None</GenerateDebugInformation> (при разработке 
// приложений пользовательского режима) и 
// <GenerateDebugInformation>Debug</GenerateDebugInformation> и 
// <GenerateDebugInformation>None</GenerateDebugInformation> (при разработке 
// драйверов режима ядра). 
// 
///////////////////////////////////////////////////////////////////////////////
// Признак сервиса Windows 
///////////////////////////////////////////////////////////////////////////////
#if !defined _NTDDK_ && defined _WIN32 
namespace trace {
inline bool IsWindowsService(HANDLE hProcess)
{
    // инициализировать переменные 
    HANDLE hToken = nullptr; DWORD sessionID = 0; DWORD cbID = sizeof(sessionID); 

    // открыть контекст процесса
    if (!::OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) return false; 

    // получить идентификатор сеанса 
    if (!::GetTokenInformation(hToken, TokenSessionId, &sessionID, cbID, &cbID)) sessionID = 0;  
    
    // проверить выполнение сервиса
    ::CloseHandle(hToken); return (sessionID != 0); 
}
}
#endif 

///////////////////////////////////////////////////////////////////////////////
// Чтение реестра 
///////////////////////////////////////////////////////////////////////////////
namespace trace {
#if defined _NTDDK_
template <size_t CCH_MAX>
inline size_t GetRegistryString(PCWSTR szKey, PCWSTR szName, PWSTR szVariable)
{
    // выделить буфер требуемого размера 
    UCHAR buffer[sizeof(KEY_VALUE_BASIC_INFORMATION) + (CCH_MAX - 1) * sizeof(WCHAR)]; 

    // выполнить преобразование типа 
    KEY_VALUE_BASIC_INFORMATION* pInfo = (KEY_VALUE_BASIC_INFORMATION*)buffer; 

    // указать имя раздела реестра 
    UNICODE_STRING ustrKey; ::RtlInitUnicodeString(&ustrKey, szKey); HANDLE hKey = NULL; 

    // указать атрибуты объекта 
    OBJECT_ATTRIBUTES attributes; InitializeObjectAttributes(
        &attributes, &ustrKey, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL
    ); 
    // открыть раздел реестра 
    NTSTATUS status = ::ZwOpenKey(&hKey, KEY_QUERY_VALUE, &attributes); 

    // проверить отсутствие ошибок 
    if (NT_ERROR(status)) return 0; ULONG cb = sizeof(buffer); 
    
    // указать имя значения 
    UNICODE_STRING ustrValue; ::RtlInitUnicodeString(&ustrValue, szName); 

    // получить информацию о значении     
    status = ::ZwQueryValueKey(hKey, &ustrValue, KeyValueBasicInformation, buffer, cb, &cb); 

    // проверить отсутствие ошибок 
    ::ZwClose(hKey); if (NT_ERROR(status)) return 0; 

    // проверить тип значения 
    if (pInfo->Type != REG_SZ && pInfo->Type != REG_EXPAND_SZ) return 0; 

    // скопировать значение 
    memcpy(szVariable, pInfo->Name, pInfo->NameLength); 
    
    // вернуть размер строки в символах
    return (pInfo->NameLength / sizeof(WCHAR)) - 1; 
}
#elif defined _WIN32 
inline size_t GetRegistryString(const char* szKey, const char* szName, char* szVariable, size_t cch)
{
    // инициализировать переменные 
    HKEY hKey = NULL; if (szVariable) szVariable[cch - 1] = 0; 

    // открыть раздел реестра
    LSTATUS status = ::RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey); 

    // проверить отсутствие ошибок
    if (status != ERROR_SUCCESS) return 0; DWORD type = 0; DWORD cb = (DWORD)cch; 

    // получить значение
    status = ::RegQueryValueExA(hKey, szName, nullptr, &type, (PBYTE)szVariable, &cb); 

    // проверить отсутствие ошибок
    ::RegCloseKey(hKey); if (status != ERROR_SUCCESS) return 0; 

    // проверить тип значения 
    if (type != REG_SZ && type != REG_EXPAND_SZ) return 0; 

    // вернуть размер переменной окружения 
    return (szVariable && szVariable[cch - 1] == 0) ? strlen(szVariable) : (cb + 1); 
}
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Чтение переменных окружения 
///////////////////////////////////////////////////////////////////////////////
namespace trace {
#if defined _NTDDK_
template <size_t CCH_MAX>
inline size_t GetSystemEnvironmentVariable(const wchar_t* szName, char* szVariable)
{
    // выделить буфер требуемого размера 
    WCHAR wszVariable[CCH_MAX] = {0}; UNICODE_STRING ustrVariable = { 
        0, (USHORT)sizeof(wszVariable), wszVariable 
    }; 
    // получить значение из реестра 
    size_t cch = GetRegistryString<CCH_MAX>(
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SessionManager", 
        szName, wszVariable
    ); 
    // проверить отсутствие ошибок 
    if (cch == 0) return 0; ustrVariable.Length = (USHORT)(cch * sizeof(WCHAR)); 

    // создать структуру описания строки  
    ANSI_STRING astrVariable = { 0, (USHORT)CCH_MAX, szVariable }; 

    // выполнить преобразование кодировки 
    NTSTATUS status = RtlUnicodeStringToAnsiString(&astrVariable, &ustrVariable, FALSE); 

    // проверить отсутствие ошибок 
    return (NT_SUCCESS(status)) ? astrVariable.Length : 0; 
}
#else 
inline size_t GetProcessEnvironmentVariable(const char* szName, char* szVariable, size_t cch)
{
#if !defined _MSC_VER
    // получить переменную окружения
    const char* szValue = getenv(szName); if (!szValue || !szValue[0]) return 0; 

    // проверить размер переменной окружения 
    size_t cb = strlen(szValue); if (cb >= cch) return 0; 
    
    // вернуть переменную окружения 
    memcpy(szVariable, szValue, cb + 1); return cb; 
#else 
    // получить переменную окружения
    return (getenv_s(&cch, szVariable, cch, szName) == 0) ? strlen(szVariable) : 0; 
#endif 
}
#if defined _WIN32 
inline size_t GetServiceEnvironmentVariable(const char* szName, char* szVariable, size_t cch)
{
    // указать имя раздела реестра
    PCSTR szKey = "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"; 

    // получить переменнюу окружения 
    return GetRegistryString(szKey, szName, szVariable, cch); 
}
#endif
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Трассировка строк фиксированного размера (см. TraceFormat.h)
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(.*s , WPP_LOGCPPVEC, const trace::_str &, ItemPString,  "s",  str, 0);
// DEFINE_CPLX_TYPE(.*hs, WPP_LOGCPPVEC, const trace::_str &, ItemPString,  "s",  str, 0);
// DEFINE_CPLX_TYPE(.*ls, WPP_LOGCPPVEC, const trace::_wstr&, ItemPWString, "s", wstr, 0);
// DEFINE_CPLX_TYPE(.*ws, WPP_LOGCPPVEC, const trace::_wstr&, ItemPWString, "s", wstr, 0);
// end_wpp

namespace trace { 
class _str { private: const char* _sz; size_t _cch;
    
    // конструктор
    public: _str(const char* sz, size_t cch) : _sz(sz), _cch(cch) {} 

    // адрес строки
    public: const char* data() const { return _sz; }

    // размер строки
    public: size_t size() const { return _cch; }
};
class _wstr { private: const wchar_t* _sz; size_t _cch;
    
    // конструктор
    public: _wstr(const wchar_t* sz, size_t cch) : _sz(sz), _cch(cch) {}

    // адрес строки
    public: const wchar_t* data() const { return _sz; }

    // размер строки
    public: size_t size() const { return _cch; }
};
}

///////////////////////////////////////////////////////////////////////////////
// Включаемые заголовочные файлы
///////////////////////////////////////////////////////////////////////////////
#include "TraceFormat.h"    // форматирование строк
#include "TraceDebug.h"     // вывод сообщений в отладчик

///////////////////////////////////////////////////////////////////////////////
// Предварительное объявление функций
///////////////////////////////////////////////////////////////////////////////
void WppTraceStringA(int level, const char   * sz, size_t cch = -1); 
void WppTraceStringW(int level, const wchar_t* sz, size_t cch = -1); 

///////////////////////////////////////////////////////////////////////////////
// Вывод сообщения в отладчик. Служебная информация WPP выводится при 
// помощи макроса WppDebug(n, MsgArgs), где n = 0 для драйверов режима ядра и 
// пользовательского режима, n = 1 для обычных приложений пользовательского 
// режима, а MsgArgs - заключенные в круглые скобки строка форматирования и 
// ее параметры. В используемой реализации указанная информация будет 
// передаваться отладчику с уровнем трассировки TRACE_LEVEL_INFORMATION. 
///////////////////////////////////////////////////////////////////////////////
inline void WppDebugPrintV(int level, const char* szFile, 
    int line, const char* szFunction, const char* szFormat, va_list& args)
{
    // отменить удаление неиспользуемых функций
    void (*pfnA)(int, const char   *, size_t) = &WppTraceStringA; (*pfnA)(0, nullptr, 0); 
    void (*pfnW)(int, const wchar_t*, size_t) = &WppTraceStringW; (*pfnW)(0, nullptr, 0);

#if !defined _NTDDK_ && defined WPP_CONTROL_GUIDS
	// проверить необходимость вывода
	if (level == TRACE_LEVEL_VERBOSE) return; 
#endif 
	// проверить необходимость вывода
	if (level == TRACE_LEVEL_NONE) return; 

    // передать сообщение отладчику
    trace::DebugPrintV(WPP_COMPNAME, "ALL", level, 
        szFile, line, szFunction, false, szFormat, args
	); 
}

inline void WppDebugPrint(int level, const char* szFile, 
    int line, const char* szFunction, const char* szFormat, ...)
{
    // перейти на переменное число параметров
    va_list args; va_start(args, szFormat); 

    // передать сообщение отладчику
	WppDebugPrintV(level, szFile, line, szFunction, szFormat, args); 	

	// освободить выделенные ресурсы
	va_end(args);
}
// добавление фиксированных параметров 
#define WPP_DEBUG_PRINT(...)	WppDebugPrint(	\
	TRACE_LEVEL_INFORMATION,                    \
	__FILE__, __LINE__, WPP_FUNC, __VA_ARGS__	\
)
// перенаправление служебной информации
#define WppDebug(n, MsgArgs) WPP_DEBUG_PRINT MsgArgs

///////////////////////////////////////////////////////////////////////////////
// Выполнение любой трассировки вида ATRACE(TRACELEVEL,...,MSG,...) определяется 
// следующим алгоритмом: 
// WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_<XXX>(...), MSG,...)
// WPP_TRACELEVEL_<XXX>_PRE(TRACELEVEL, ...)
// ((
//     WPP_TRACELEVEL_<XXX>_ENABLED(TRACELEVEL, ...)
//     ? WPP_INVOKE_WPP_DEBUG((MSG,...)), WPP_SF_<SIG>(...), 1 : 0
// ))
// WPP_TRACELEVEL_<XXX>_POST(TRACELEVEL, ...)
///////////////////////////////////////////////////////////////////////////////
// 1) Макрос WPP_LOG_ALWAYS используется для дополнительного вывода сообщений 
//    в отладчик. Ему передаются все параметры, возвращаемые макросом
//    WPP_EX_TRACELEVEL_<XXX>, а также строка форматирования и ее аргументы. 
//    Параметры, возвращаемые макросом WPP_EX_TRACELEVEL_<XXX>, используются 
//    для проверки необходимости вывода сообщений, а также определения уровня 
//    трассировки, используемого в отладчике. Если переданный уровень равен 
//    TRACE_LEVEL_NONE, то вывод в отладчик не производится. В противном случае, 
//    a) в режиме ядра вывод в отладчик осуществляется в соответствии со 
//       следующей таблицей: 
//       TRACE_LEVEL_CRITICAL    -> DPFLTR_ERROR_LEVEL;
//       TRACE_LEVEL_ERROR       -> DPFLTR_ERROR_LEVEL;
//       TRACE_LEVEL_WARNING     -> DPFLTR_WARNING_LEVEL;
//       TRACE_LEVEL_INFORMATION -> DPFLTR_INFO_LEVEL;
//       TRACE_LEVEL_VERBOSE     -> DPFLTR_TRACE_LEVEL;
//    b) в режиме пользователя уровень трассировки игнорируется и вывод 
//       в отладчик производится всегда, за исключением уровня 
//       TRACE_LEVEL_VERBOSE при наличии ETW-трассировки. 
// 2) Макрос WPP_EX_TRACELEVEL_<XXX>, как уже сказано выше, предназначен 
//    для передачи дополнительных параметров макросу WPP_LOG_ALWAYS. Среди 
//    указанных параметров должен быть уровень трассировки, используемый 
//    в отладчике. 
// 3) Макрос WPP_TRACELEVEL_<XXX>_PRE предназначен для выполнения 
//    дополнительных предварительных действий до непосредственного момента 
//    трассировки. 
// 4) Макрос WPP_TRACELEVEL_<XXX>_ENABLED проверяет необходимость 
//    выполнения трассировки (например, соответствие уровня трассировки 
//    используемому уровню трассировки в сеансе). 
// 5) Макрос WPP_INVOKE_WPP_DEBUG выполняется только отладочном режиме 
//    непосредственно перед трассировкой, принимает в качестве параметров 
//    строку форматирования и ее аргументы и определяется через макрос 
//    WPP_DEBUG. Если макрос WPP_DEBUG не определен, то макрос 
//    WPP_INVOKE_WPP_DEBUG ничего не выполняет. 
// 6) Функция WPP_SF_<SIG> является оберточной функцией для макроса 
//    трассировки WPP_TRACE, который непосредственно и выполняет 
//    трассировку параметров. По умолчанию в режиме пользователя
//    макрос WPP_TRACE раскрывается в вызов функции TraceMessage. 
// 7) Макрос WPP_TRACELEVEL_<XXX>_POST предназначен для выполнения 
//    дополнительных завершающих действий. 
///////////////////////////////////////////////////////////////////////////////
// Замечания к реализации. 
///////////////////////////////////////////////////////////////////////////////
// 1) Поскольку строка форматирования и ее аргументы во всех версиях продукта
//    (Debug и Release) передаются только макросу WPP_LOG_ALWAYS, то 
//    вывод в отладчик отфоматированной строки может быть только при 
//    выполнении макроса WPP_LOG_ALWAYS (вариант сохранения параметров 
//    в макросе WPP_LOG_ALWAYS не рассматривается, поскольку для такой 
//    реализации потребуется шаблонный класс с переменным числом параметров, 
//    что не поддерживается в старых версиях Visual Studio, например, VS 2008). 
// 2) Поскольку при проверке отсутствия ошибок среди аргументов функции 
//    форматирования присутствует аргумент признака (кода) ошибки, который 
//    может раскрываться в вызов функции, то макрос WPP_LOG_ALWAYS должен 
//    сохранить его во временной переменной для последующего использования 
//    указанной временной переменной, а не повторного раскрытия макроса, 
//    приводящего к новому вызову функции. 
// 3) Для проверки необходимости вывода отформатированного сообщения в 
//    отладчик макросу WPP_LOG_ALWAYS должна передаваться функция или 
//    другой макрос проверки допустимости вывода (например, макрос
//    WPP_TRACELEVEL_<XXX>_ENABLED). В текущей реализации это выполняется 
//    передачей макросу WPP_LOG_ALWAYS макроса проверки допустимости, 
//    который будет однократно вызван внутри макроса WPP_LOG_ALWAYS.
// 4) Объединяя п.1)-3), макрос WPP_EX_TRACELEVEL_<XXX> должен передать 
//    макросу WPP_LOG_ALWAYS как минимум 4 параметра: 
//    a) тип переменной, в которой должен сохраняться однократно 
//       вычисляемый аргумент (код или признак ошибки); 
//    b) значение или способ вычисления аргумента; 
//    с) имя макроса, проверяющего допустимость вывода; 
//    d) уровень трассировки, выполняемой отладчиком. 
// 5) Если в качестве результата макроса WPP_EX_TRACELEVEL_<XXX> указать 
//    упомянутые параметры через запятую без дополнительных разделителей, 
//    то компилятор Microsoft ошибочно (не в соответствии со стандартом) 
//    не "распакует" результат в последовательные параметры макроса 
//    WPP_LOG_ALWAYS, а в "упакованном" виде весь результат (т.е. все 
//    параметры) передаcт на место первого параметра макроса. Поэтому 
//    для возможности использования указанных параметров применяется 
//    следующий совместимый со стандартом метод: 
//    a) макрос WPP_EX_TRACELEVEL_<XXX> возвращает указанные параметры в 
//       круглых скобках (что дополнительно наглядно группирует параметры); 
//    b) определяются 4 макросные функции извлечения параметров: 
//       #define WPP_LOG_EXTRACT_TYPE( TYPE, VALUE, CHECK, LEVEL) TYPE
//       #define WPP_LOG_EXTRACT_VALUE(TYPE, VALUE, CHECK, LEVEL) VALUE
//       #define WPP_LOG_EXTRACT_CHECK(TYPE, VALUE, CHECK, LEVEL) CHECK
//       #define WPP_LOG_EXTRACT_LEVEL(TYPE, VALUE, CHECK, LEVEL) LEVEL 
//    c) указанные макросные функции вставляются в макрос WPP_LOG_ALWAYS 
//       без скобок (чтобы избежать преждевременного раскрытия). Скобки же 
//       подставляются при подстановке результата макроса 
//       WPP_EX_TRACELEVEL_<XXX>. 
///////////////////////////////////////////////////////////////////////////////
#if !defined WPP_CONTROL_GUIDS 
#ifdef WPP_DEBUG
#define WPP_INVOKE_WPP_DEBUG(MsgArgs) WPP_DEBUG(MsgArgs)
#else
#define WPP_INVOKE_WPP_DEBUG(MsgArgs) (void)0
#endif
#endif

// извлечение отдельных параметров 
#define WPP_LOG_EXTRACT_TYPE( TYPE, VALUE, CHECK, LEVEL)    TYPE
#define WPP_LOG_EXTRACT_VALUE(TYPE, VALUE, CHECK, LEVEL)    VALUE
#define WPP_LOG_EXTRACT_CHECK(TYPE, VALUE, CHECK, LEVEL)    CHECK
#define WPP_LOG_EXTRACT_LEVEL(TYPE, VALUE, CHECK, LEVEL)    LEVEL

// вывод в отладчик
#define WPP_LOG_ALWAYS(ARGS, ...)                {      \
    WPP_LOG_EXTRACT_TYPE ARGS WPP_VAR(__LINE__) =       \
        WPP_LOG_EXTRACT_VALUE ARGS;                     \
    if (WPP_LOG_EXTRACT_CHECK ARGS(WPP_VAR(__LINE__)))  \
    WppDebugPrint(										\
        WPP_LOG_EXTRACT_LEVEL ARGS,                  	\
        __FILE__, __LINE__, WPP_FUNC,                	\
        __VA_ARGS__                                     \
    ); 

///////////////////////////////////////////////////////////////////////////////
// Переопределение функции трассировки для предотвращения изменения кода 
// последней ошибки в системе (что происходило в старых версиях функции 
// TraceMessage)
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS && !defined _NTDDK_
inline DWORD WppTraceMessage(
    IN TRACEHANDLE hLogger, IN ULONG messageFlags, 
    IN LPCGUID messageGuid, IN USHORT messageNumber, ...)
{
    // сохранить код последней ошибки
    DWORD lastError = ::GetLastError();

    // перейти на переменное число аргументов
    va_list args; va_start(args, messageNumber);

    // выполнить стандартную функцию трассировки
    DWORD code = CallTraceMessageVa(
        hLogger, messageFlags, messageGuid, messageNumber, args
    );
    // восстановить код ошибки
    va_end(args); ::SetLastError(lastError); return code; 
}
// функции трассировки и обработки событий 
#define WPP_REGISTER_TRACE_GUIDS    WppRegisterTraceGuids
#define WPP_UNREGISTER_TRACE_GUIDS  WppUnregisterTraceGuids
#define WPP_PRIVATE_ENABLE_CALLBACK WppNotificationCallback
#define WPP_TRACE                   WppTraceMessage
#endif 

///////////////////////////////////////////////////////////////////////////////
// Универсальные способы определения ошибки
///////////////////////////////////////////////////////////////////////////////
#define WPP_CAST_BOOL(code)      (code)

///////////////////////////////////////////////////////////////////////////////
// Основная трассировка выполняется через функцию ATRACE(TRACELEVEL, MSG, ...), 
// второй параметр которой (строка форматирования) должен быть известен на 
// этапе компиляции. 
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC ATRACE(TRACELEVEL, MSG, ...);
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL(LEVEL)            (int, 1, WPP_CAST_BOOL, LEVEL)

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_PRE(LEVEL)           (void)WPP_VAR(__LINE__);

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_POST(LEVEL)          ;}

#ifdef WPP_CONTROL_GUIDS

// Описатель сеанса трассировки
#define WPP_TRACELEVEL_LOGGER(LEVEL)        WppGetLogger(),

// Проверка допустимости трассировки для указанного уровня
#define WPP_TRACELEVEL_ENABLED(LEVEL)       (WppGetControl()->Level >= LEVEL)

#else 

// Проверка допустимости трассировки
#define WPP_TRACELEVEL_ENABLED(LEVEL)       (1) 

// Вывод трассировки
#define ATRACE(LEVEL, ...)                                     \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL(LEVEL), __VA_ARGS__)      \
    WPP_TRACELEVEL_PRE(LEVEL)                                  \
    (void)((                                                   \
        WPP_TRACELEVEL_ENABLED(LEVEL)                          \
        ? WPP_INVOKE_WPP_DEBUG((__VA_ARGS__)), 1 : 0           \
    ))                                                         \
    WPP_TRACELEVEL_POST(LEVEL)                                       
#endif 

///////////////////////////////////////////////////////////////////////////////
// Стандартные определения трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#define WPP_USER_MSG_GUID (77921413, 5345, 4626, B028, C3AFB9DCBF05)
#if defined _NTDDK_
#include "TraceDriver.h"
#else 
#include "TraceUser.h"
#endif 
#else 
#if defined _NTDDK_
#define WPP_INIT_TRACING(pDriver, pRegPath) UNREFERENCED_PARAMETER(pRegPath)
#define WPP_CLEANUP(     pDriver)           UNREFERENCED_PARAMETER(pDriver) 
#else 
#define WPP_INIT_TRACING(Application)       ((void)0)
#define WPP_CLEANUP(                )       ((void)0)
#endif 
#endif 

///////////////////////////////////////////////////////////////////////////////
// Найти описание провайдера трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#if !defined _NTDDK_
inline PWPP_TRACE_CONTROL_BLOCK WppGetControl(TRACEHANDLE hRegistrationHandle)
{
    // проверить наличие регистрации
    if (WPP_CB == (WPP_CB_TYPE*)&WPP_CB) return nullptr; 

    // перейти на блок первого компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = &WPP_CB[0].Control;

    // для всех зарегистрированных компонентов
    for(; pControl; pControl = pControl->Next) 
    {
        // проверить наличие идентификатора
        if (!pControl->ControlGuid) continue; 

        // проверить совпадение идентификатора
        if (pControl->UmRegistrationHandle == hRegistrationHandle) return pControl;
    }
    return nullptr; 
}
#endif 

inline PWPP_TRACE_CONTROL_BLOCK WppGetControl(const GUID& componentGUID)
{
    // проверить наличие регистрации
    if (WPP_CB == (WPP_CB_TYPE*)&WPP_CB) return nullptr; 

    // перейти на блок первого компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = &WPP_CB[0].Control;

    // для всех зарегистрированных компонентов
    for(; pControl; pControl = pControl->Next) 
    {
        // проверить наличие идентификатора
        if (!pControl->ControlGuid) continue; 

        // проверить совпадение идентификатора
        if (IsEqualGUID(*pControl->ControlGuid, componentGUID)) return pControl;
    }
    return nullptr; 
}

inline PWPP_TRACE_CONTROL_BLOCK WppGetControl()
{
    // указать идентификатор компонента
    GUID componentGUID = WPP_XGLUE4(WPP_, ThisDir, _CTLGUID_, WPP_EVAL(WPP_CONTROL_NAME)); 

    // найти блок компонента
    return WppGetControl(componentGUID); 
}

inline TRACEHANDLE WppGetLogger()
{
    // найти блок компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(); 

#if !defined _NTDDK_
    // для специального случая
    if (pControl && pControl->Options == WPP_VER_WIN2K_CB_FORWARD_PTR)
    {
        // вернуть описатель сеанса
        if (pControl->Win2kCb) return pControl->Win2kCb->Logger; 
    }
    // для специального случая
    if (pControl && pControl->Options == WPP_VER_WHISTLER_CB_FORWARD_PTR)
    {
        // скорректировать блок компонента
        if (pControl->Cb) pControl = pControl->Cb; 
    }
#endif 
    // вернуть описатель сеанса
    return (pControl) ? pControl->Logger : 0; 
}

///////////////////////////////////////////////////////////////////////////////
// Параметры трассировки (переменные окружения)
///////////////////////////////////////////////////////////////////////////////
namespace trace {
class ControlParameters
{ 
	// конструктор
	public: ControlParameters() { Update(); } 
#if defined _NTDDK_
    // инициализация объекта в месте размещения
    public: void* operator new(size_t, void* p) { return p; }
#endif 
    // обновить значения переменных
    public: void Update(); private: char prefix[256];
	// значение префикса
	public: const char* DebugPrefix() const 
	{ 
		// значение префикса
		return (prefix[0]) ? prefix : nullptr; 
	}
};

#if defined _NTDDK_
inline void ControlParameters::Update()
{
    // получить значение переменной окружения 
    GetSystemEnvironmentVariable<sizeof(prefix)>(L"TRACE_FORMAT_PREFIX", prefix); 
}
#elif defined _WIN32 
inline void ControlParameters::Update()
{
    // инициализировать переменные 
    PCSTR szValue = "TRACE_FORMAT_PREFIX"; if (IsWindowsService(::GetCurrentProcess()))
    {
        // получить переменную окружения
        size_t cch = GetServiceEnvironmentVariable(szValue, prefix, sizeof(prefix)); 
        
        // установить переменную окружения
        ::SetEnvironmentVariableA(szValue, cch ? prefix : nullptr); 
    }
    // получить переменную окружения
    else GetProcessEnvironmentVariable(szValue, prefix, sizeof(prefix)); 
}
#else 
inline void ControlParameters::Update()
{
    // получить переменную окружения
    GetProcessEnvironmentVariable("TRACE_FORMAT_PREFIX", prefix, sizeof(prefix)); 
}
#endif

#if !defined WPP_CONTROL_GUIDS 
inline const ControlParameters* GetControlParameters() 
{ 
	// получить способ записи префикса
	static ControlParameters parameters; return &parameters;
}
#elif defined _NTDDK_
#pragma warning(disable: 4996)
inline const ControlParameters* GetControlParameters() 
{
    // найти блок компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(); 
    
    // проверить наличие блока 
    if (!pControl) return nullptr; UNICODE_STRING ustProcName = {0}; 

    // получить адрес функции EtwRegisterClassicProvider
    RtlInitUnicodeString(&ustProcName, L"EtwRegisterClassicProvider");

    // инициализировать адрес ячейки с адресом
    ControlParameters** ppParameters = nullptr; 

    // при наличии функции EtwRegisterClassicProvider
    if (MmGetSystemRoutineAddress(&ustProcName))
    {
        // указать используемую ячейку
        ppParameters = (ControlParameters**)&pControl->Callback; 
    }
    else {
        // указать используемую ячейку
        ppParameters = (ControlParameters**)&pControl->RegHandle; 
    }
    // проверить наличие адреса структуры 
    if (*ppParameters) return *ppParameters; 

    // выделить память для структуры 
    if (ControlParameters* pParameters = (ControlParameters*)
        ExAllocatePoolWithTag(PagedPool, sizeof(ControlParameters), 'crtA'))
    {
        // инициализировать структуру 
        new (*ppParameters = pParameters) ControlParameters();
    }
    return *ppParameters; 
}
#pragma warning(default: 4996)
#elif defined _WIN32
inline const ControlParameters* GetControlParameters() 
{
    // найти блок компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(); if (!pControl) return nullptr; 
    
    // проверить наличие блока
    if (pControl->Options != WPP_VER_WHISTLER_CB_FORWARD_PTR || !pControl->Cb) return nullptr; 

    // выполнить преобразование типа
    return (const ControlParameters*)(pControl->Cb->Next); 
}
#endif 

inline const char* GetDebugPrefix() 
{
	// получить параметры управления
	if (const ControlParameters* pControlParameters = GetControlParameters())
	{
		// получить способ форматирования префикса
		if (const char* szPrefix = pControlParameters->DebugPrefix()) 
		{
			// пропустить начальные пробелы
			szPrefix = szPrefix + strspn(szPrefix, " "); 

			// проверить указание префикса
			if (strcmp(szPrefix, "%0") != 0) return szPrefix; 

			// указать значение префикса по умолчанию
			return "[%9!d!]%8!04X!.%3!04X!::%4!s! [%1!s!] %2!s! "; 
		}
	}
	return nullptr; 
}
}

///////////////////////////////////////////////////////////////////////////////
// Регистрация идентификаторов трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined _NTDDK_
#pragma warning(disable: 4996)
inline void WppNotificationCallback(LPCGUID ControlGuid, 
    TRACEHANDLE, BOOLEAN enable, ULONG, UCHAR) 
{
    // найти основной блок управления
    if (!enable) return; PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(*ControlGuid); 

    // проверить корректность настроек
    if (!pControl) return; UNICODE_STRING ustProcName = {0}; 

    // получить адрес функции EtwRegisterClassicProvider
    RtlInitUnicodeString(&ustProcName, L"EtwRegisterClassicProvider");

    // инициализировать адрес ячейки с адресом
    trace::ControlParameters** ppParameters = nullptr; 

    // при наличии функции EtwRegisterClassicProvider
    if (MmGetSystemRoutineAddress(&ustProcName))
    {
        // указать используемую ячейку
        ppParameters = (trace::ControlParameters**)&pControl->Callback; 
    }
    else {
        // указать используемую ячейку
        ppParameters = (trace::ControlParameters**)&pControl->RegHandle; 
    }
    // обновить параметры трассировки
    if (*ppParameters) (*ppParameters)->Update(); 
    else {
        // выделить память для структуры 
        if (trace::ControlParameters* pParameters = 
            (trace::ControlParameters*)ExAllocatePoolWithTag(
                PagedPool, sizeof(trace::ControlParameters), 'crtA'))
        {
            // инициализировать структуру 
            new (*ppParameters = pParameters) trace::ControlParameters();
        }
    }
}
#pragma warning(default: 4996)
#elif defined _WIN32
inline ULONG WppRegisterTraceGuids(
    WMIDPREQUEST RequestAddress, PVOID RequestContext, 
    LPCGUID ControlGuid, ULONG GuidCount, PTRACE_GUID_REGISTRATION TraceGuidReg, 
    LPCWSTR MofImagePath, LPCWSTR MofResourceName, PTRACEHANDLE phRegistrationHandle)
{
    // вызвать базовую функцию
    ULONG ret = ::RegisterTraceGuidsW(RequestAddress, RequestContext, 
        ControlGuid, GuidCount, TraceGuidReg, 
        MofImagePath, MofResourceName, phRegistrationHandle
    ); 
    // проверить отсутствие ошибок
    if (ret != ERROR_SUCCESS) return ret; 

    // найти основной блок управления
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(*phRegistrationHandle); 

    // проверить корректность настроек
    if (!pControl || pControl->Options != 0) return ret; 

    // выделить память для дополнительного блока управления
    if (PWPP_TRACE_CONTROL_BLOCK pCB = new WPP_TRACE_CONTROL_BLOCK)
    {
        // выполнить инициализацию
        pCB->Options = 0; pCB->Logger = pControl->Logger; 

        // указать используемое перенаправление
        pControl->Options = WPP_VER_WHISTLER_CB_FORWARD_PTR; pControl->Cb = pCB; 

        // указать данные основного блока управления
        pCB->UmRegistrationHandle = pControl->UmRegistrationHandle; 

        // указать данные основного блока управления
        pCB->ControlGuid = ControlGuid; pCB->Level = pControl->Level; 
        
        // указать данные основного блока управления
        pCB->FlagsLen = pControl->FlagsLen; pCB->Flags[0] = pControl->Flags[0]; 

        // прочитать параметры трассировки
        trace::ControlParameters* pControlParameters = new(std::nothrow) trace::ControlParameters(); 

        // сохранить значения параметров трассировки
        pCB->Next = (PWPP_TRACE_CONTROL_BLOCK)pControlParameters; 
    }
    return ret; 
}

inline ULONG WppUnregisterTraceGuids(TRACEHANDLE hRegistrationHandle)
{
    // найти основной блок управления
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(hRegistrationHandle); 

    // проверить корректность настроек
    if (pControl && pControl->Options == WPP_VER_WHISTLER_CB_FORWARD_PTR) 
    {
        // получить адрес дополнительного блока
        if (PWPP_TRACE_CONTROL_BLOCK pCB = pControl->Cb)
        {        
            // восстановить исходные данные
            pControl->Options = 0; pControl->Logger = pCB->Logger; 

            // восстановить исходные данные
            pControl->UmRegistrationHandle = pCB->UmRegistrationHandle; 
            
            // восстановить исходные данные
            pControl->ControlGuid = pCB->ControlGuid; pControl->Level = pCB->Level; 

            // восстановить исходные данные
            pControl->FlagsLen = pCB->FlagsLen; pControl->Flags[0] = pCB->Flags[0];

            // освободить выделенную память
            if (pCB->Next) delete (trace::ControlParameters*)(pCB->Next); delete pCB; 
        }
    }
    // вызвать базовую функцию
    return ::UnregisterTraceGuids(hRegistrationHandle); 
}

inline void WppNotificationCallback(LPCGUID ControlGuid, 
    TRACEHANDLE hLogger, BOOLEAN enable, ULONG flags, UCHAR level) 
{
    // найти основной блок управления
    if (!enable) return; PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(*ControlGuid); 

    // проверить корректность настроек
    if (!pControl || pControl->Options != WPP_VER_WHISTLER_CB_FORWARD_PTR) return; 

    // получить адрес дополнительного блока
    if (PWPP_TRACE_CONTROL_BLOCK pCB = pControl->Cb)
    {
        // сохранить принятые данные
        pCB->Logger = hLogger; pCB->Level = level; pCB->Flags[0] = flags; 

        // обновить параметры трассировки
        ((trace::ControlParameters*)(pCB->Next))->Update(); 
    }
}
#endif 
#endif

///////////////////////////////////////////////////////////////////////////////
// Трассировка входа/выхода из функции. Функции класса не должны быть 
// встраиваемыми (inline) во избежание следующих проблем: 
// 1) неcоответствия принадлежности конструктора и деструктора класса 
// различным единицам трансляции и, следовательно, рассогласования при выводе 
// трассировки (различные значения __FILE__ и принадлежность номеров строк
// различным файлам); 
// 2) помещения в .TMF-файл для трассировочных сообщений Trace.h описания 
// сообщений, принадлежащих другим единицам трансляции (единицам трансляции, 
// в которые встраиваются вызовы конструктора и деструктора). 
///////////////////////////////////////////////////////////////////////////////
namespace trace { 
class scope { private: const char* szFunction; 

    // конструктор
    public: WPP_NOINLINE scope(const char* szFunc) : szFunction(szFunc)
    {
        // выполнить трассировку входа
        ATRACE(TRACE_LEVEL_VERBOSE, "--> %hs", szFunction);
    }
    // деструктор
    public: WPP_NOINLINE ~scope()
    {
        // выполнить трассировку выхода
        ATRACE(TRACE_LEVEL_VERBOSE, "<-- %hs", szFunction);
    }
};    
}
// встраивание трассировки стека
#define $ trace::scope WPP_VAR(__LINE__)(WPP_FUNC);

///////////////////////////////////////////////////////////////////////////////
// Трассировка строки фиксированного размера
///////////////////////////////////////////////////////////////////////////////
WPP_NOINLINE inline void WppTraceStringA(int level, const char* sz, size_t cch) 
{ 
    // определить размер строки
    if (!sz) { return; } if (cch == (size_t)(-1)) { cch = strlen(sz); } switch (level)
    {
    // вывести строку
    case TRACE_LEVEL_NONE       : ATRACE(TRACE_LEVEL_NONE       , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_CRITICAL   : ATRACE(TRACE_LEVEL_CRITICAL   , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_ERROR      : ATRACE(TRACE_LEVEL_ERROR      , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_WARNING    : ATRACE(TRACE_LEVEL_WARNING    , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_INFORMATION: ATRACE(TRACE_LEVEL_INFORMATION, "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_VERBOSE    : ATRACE(TRACE_LEVEL_VERBOSE    , "%!.*hs!", trace::_str(sz, cch)); break;
    }
}

WPP_NOINLINE inline void WppTraceStringW(int level, const wchar_t* sz, size_t cch) 
{ 
    // определить размер строки
    if (!sz) { return; } if (cch == (size_t)(-1)) { cch = wcslen(sz); } switch (level)
    {
    // вывести строку
    case TRACE_LEVEL_NONE       : ATRACE(TRACE_LEVEL_NONE       , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_CRITICAL   : ATRACE(TRACE_LEVEL_CRITICAL   , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_ERROR      : ATRACE(TRACE_LEVEL_ERROR      , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_WARNING    : ATRACE(TRACE_LEVEL_WARNING    , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_INFORMATION: ATRACE(TRACE_LEVEL_INFORMATION, "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_VERBOSE    : ATRACE(TRACE_LEVEL_VERBOSE    , "%!.*ls!", trace::_wstr(sz, cch)); break;
    }
}
inline void ATRACESTR(int level, const char   * sz, size_t cch = -1) { WppTraceStringA(level, sz, cch); }
inline void ATRACESTR(int level, const wchar_t* sz, size_t cch = -1) { WppTraceStringW(level, sz, cch); }

///////////////////////////////////////////////////////////////////////////////
// Выполнить трассировку содержимого буфера
///////////////////////////////////////////////////////////////////////////////
inline void ATRACEDUMP(int level, const void* pvBlock, size_t cbBlock)
{
    static const char DIGITS[] = {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };
    // выполнить преобразование типа
    const unsigned char* pbBlock = (const unsigned char*)pvBlock; 

    // создать буфер требуемого размера
    char buffer[2 * sizeof(void*) + 2 + 64 + 1] = {0}; 

    // определить адрес для форматируемого значения
    char* szValue = buffer + 2 * sizeof(void*) + 2; 

    // для всех строк
    for (size_t i = 0; i < (cbBlock + 15) / 16; i++)
    {
        // вычислить базовый адрес
        const unsigned char* ptr = pbBlock + i * 16; memset(szValue, ' ', 64);

        // отформатировать адрес
        trace::snprintf_ptr(buffer, 2 * sizeof(void*) + 1, ptr); 

        // указать разделитель адреса и значения
        buffer[2 * sizeof(void*) + 0] = ':'; buffer[2 * sizeof(void*) + 1] = ' '; 

        // для всех байтов строки
        for (size_t j = 0; (j < 16) && (i * 16 + j < cbBlock); j++)
        {
            // извлечь отдельный байт
            unsigned char ch = ptr[j];

            // указать шестнадцатеричное представление
            szValue[j * 3 + 0] = DIGITS[ch / 16];
            szValue[j * 3 + 1] = DIGITS[ch % 16];

            // указать символьное представление
            szValue[48 + j] = (' ' <= ch && ch <= 127) ? ch : '.';
        }
        // выполнить трассировку
        ATRACESTR(level, buffer);
    }                                                                   
}

///////////////////////////////////////////////////////////////////////////////
// Выполнить многострочную трассировку ошибки
///////////////////////////////////////////////////////////////////////////////
inline void ATRACE_MULTILINE(int level, const char* szMessage)
{
    // для всех подстрок
    while (szMessage && *szMessage)
    {
        // найти завершение подстроки
        if (const char* szLast = strchr(szMessage, '\n')) 
        { 
            // указать позицию окончания вывода
            const char* szEnd = szLast; if (szLast != szMessage)
            {
                // указать позицию окончания вывода
                if (*(szLast - 1) == '\r') szEnd--; 
            }
            // вывести подстроку
            ATRACESTR(level, szMessage, szEnd - szMessage);

            // пропустить подстроку
            szMessage = szLast + 1; continue; 
        }
        // вывести оставшуюся строку
        ATRACESTR(level, szMessage); break; 
    }
}
inline void ATRACE_MULTILINE(int level, const wchar_t* szMessage)
{
    // для всех подстрок
    while (szMessage && *szMessage)
    {
        // найти завершение подстроки
        if (const wchar_t* szLast = wcschr(szMessage, L'\n')) 
        { 
            // указать позицию окончания вывода
            const wchar_t* szEnd = szLast; if (szLast != szMessage)
            {
                // указать позицию окончания вывода
                if (*(szLast - 1) == L'\r') szEnd--; 
            }
            // вывести подстроку
            ATRACESTR(level, szMessage, szEnd - szMessage);

            // пропустить подстроку
            szMessage = szLast + 1; continue; 
        }
        // вывести оставшуюся строку
        ATRACESTR(level, szMessage); break; 
    }
}

///////////////////////////////////////////////////////////////////////////////
// Сбросить идентификатор служебных сообщений
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#undef WPP_USER_MSG_GUID
#endif 
