///////////////////////////////////////////////////////////////////////////////
// Трассировка Event Tracing for Windows (ETW)
///////////////////////////////////////////////////////////////////////////////
// Генерация событий в ETW производится провайдерами трассировки (event trace 
// providers). Управление провайдерами трассировки (включающее регистрацию 
// провайдера, отмену регистрации провайдера и генерацию событий) 
// осуществляется из кода приложений, которые генерируют события трассировки. 
// Прием сообщений о событиях в ETW осуществляют сеансы трассировки (event 
// trace sessions). Провайдеры трассировки, в зависимости от своего типа, могут 
// пересылать сообщения как нескольким сеансам трассировки, так и только одному 
// сеансу трассировки. 
// 
// Каждый провайдер трассировки идентифицируется своим GUID. В ETW провайдеры 
// бывают следующих типов: 
// 1) провайдеры Managed Object Format (MOF). Частным случаем MOF-провайдеров 
//    являются провайдеры Windows Preprocessor Software Tracing (WPP);  
// 2) провайдеры, основанные на манифесте;
// 3) провайдеры TraceLogging. 
// Отличие различных типов провайдеров заключается в используемых функциях 
// регистрации, числе сеансов, которые могут принимать сообщения от провайдера,  
// и связывания бинарных данных, передаваемых в сообщениях, с подробным 
// описанием событий, хранимых отдельно от сообщений. 
// 
// Управление сеансами трассировки (создание, удаление, изменение параметров) 
// осуществляется (в зависимости от типа сеанса) либо на основании значений 
// системного реестра, либо контроллерами трассировки (trace controllers) -  
// приложениями, функционирующими в пользовательском режиме и использующими 
// специальное API (controller API). 
// 
// Контроллеры трассировки создают сеанс трассировки с использованием функции 
// StartTrace, а завершают сеанс трассировки с использованием функции 
// ControlTrace с передачей ей кода EVENT_TRACE_CONTROL_STOP. Настройка 
// контроллером принимаемых сеансом сообщений производится функцией 
// EnableTrace, а изменение других параметров сеанса - функцией ControlTrace. 
// При вызове контроллером функции EnableTrace об этом уведомляется провайдер 
// трассировки через зарегистрированную функцию обратного вызова. 
// 
// Каждый сеанс трассировки идентифицируется своим GUID, который, как правило, 
// генерируется автоматически. Сеансы трассировки бывают следующих типов: 
// 1) GlobalLogger. Может быть только один сеанс указанного типа c GUID, равным 
//    GlobalLoggerGuid. Сеанс предназначен для приема сообщений, которые не 
//    принимаются другими сеансами. В основном, это касается сообщений, 
//    генерируемых драйверами устройств на этапе загрузки операционной системы, 
//    а также сообщений о специальных событиях от ядра операционной системы. 
//    Сеанс запускается при загрузке операционной системы и управляется 
//    параметрами из системного реестра, в котором перечислены допустимые 
//    провайдеры трассировки. Сеанс не оповещает о своем запуске провайдеры 
//    трассировки, перечисленные в реестре; 
// 2) AutoLogger (начиная с Windows Vista). Может быть несколько сеансов 
//    указанного типа. Сеансы запускаются при загрузке операционной системы и   
//    управляются параметрами из системного реестра, в котором перечислены 
//    допустимые провайдеры трассировки. В отличие от сеанса GlobalLogger, 
//    cеансы AutoLogger оповещают о своем запуске перечисленные в реестре 
//    провайдеры трассировки, но не могут принимать сообщения о специальных 
//    событиях от ядра операционной системы; 
// 3) Сеансы с системным провайдером. Cеансы предназначены для приема сообщений 
//    только от ядра операционной системы после ее загрузки и связаны только 
//    с системным провайдером. Сеансы управляются контроллером и не используют 
//    системный реестр. До Windows 8/Windows Server 2012 мог быть только один 
//    сеанс указанного типа, называемый NT Kernel Logger с GUID, равным 
//    SystemTraceControlGuid. Начиная с Windows 8/Windows Server 2012, может 
//    быть до 8 сеасов с системным провайдером, среди которых может быть и 
//    NT Kernel Logger;  
// 4) Event Tracing. Может быть несколько сеансов указанного типа. Сеанс 
//    предназначен для приема сообщений после загрузки операционной системы. 
//    Такими сообщениями могут быть как сообщения от провайдеров трассировки 
//    драйверов устройств, так и сообщения от провайдеров трассировки 
//    пользовательского режима. Сеанс управляется контроллером и не использует 
//    системный реестр. Сеанс оповещает о своем запуске и изменении параметров 
//    требуемые провайдеры трассировки;
// 5) Private Logger. Сеанс предназначен для приема сообщений от провайдеров 
//    трассировки пользовательского режима и может создаваться только в 
//    адресном пространстве процесса указанных провайдеров. Может быть 
//    несколько сеансов указанного типа. Сеанс управляется контроллером и 
//    не использует системный реестр. Сеанс оповещает о своем запуске и 
//    изменении параметров провайдеры трассировки. 
// Общее число сеансов трассировки не может превышать 32 для Windows 2000 и 
// 64 для последующих версий Windows (в это число не включаются сеансы 
// Private Logger). 
// 
// В сеансах трассировки сообщения сохраняются в специальных буферах, которые 
// в определенные моменты времени, в зависимости от режима работы сеанса, 
// могут сбрасываться в файлы на диске или передаваться потребителям 
// трассировки (trace consumers), подключенным к сеансам. Возможно выполнение 
// обоих вариантов, а также варианта, в котором при переполнении буферов новые
// сообщения начинают перезаписывать старые сообщения без их внешнего 
// сохранения и передачи. 
// 
// Потребители трассировки подключаются к сеансам трассировки функцией 
// OpenTrace, а отключаются - функцией CloseTrace. При вызове функции OpenTrace 
// ей передаются функции обратного вызова, вызываемые сеансом для передачи 
// входящих сообщений потребителю. Цикл обработки потребителем сообщений от 
// сеанса инициируется вызовом функции ProcessTrace. 
// 
// Запись сообщений в файлы или передача их потребителям производится сеансом 
// при полном заполнении одного из буферов, при закрытии сеанса и через 
// промежутки времени, задаваемый параметром FlushTimer. Если буферы 
// заполняются быстрее, чем очищаются, то ETW выделяет новые буферы для 
// предотвращения потери сообщений. Начальное число буферов в сеансе 
// определяется параметром MinimumBuffers, максимальное число - параметром 
// MaximumBuffers, а размер каждого буфера - параметром BufferSize. При 
// заполнении максимального числа буферов вновь поступающие сообщения 
// отбрасываются, поэтому в ETW возможна потеря сообщений. 
// 
// С каждым принятым сообщением в буферах сохраняется время его появления. 
// Указанное время может быть одним из следующих: счетчик высокой 
// производительности (query performance counter), системное время (FILETIME) 
// или счетчик циклов процессора (Time Stamp Counter, TSC). Тип используемого 
// времени определяется параметром ClockType. Заметим, что счетчик высокой 
// производительности и счетчик циклов процессора представляют собой 
// относительное время, поэтому в начале трассировки сохраняется системное 
// время, значение которого вместе со значением сохраняемого относительного 
// времени позволяет вычислить абсолютное системное время. 
// 
// Основной режим работы сеанса трассировки, а также его модификации, задается 
// параметром LogFileMode. Указанный параметр предсталяет собой битовую маску, 
// в которой основной режим задают следующие биты (EVENT_TRACE_FILE_MODE_NONE 
// не является битом, а представляет собой нулевое значение, которое 
// используется при отсутствии установки других битов): 
// 1) EVENT_TRACE_BUFFERING_MODE - режим циклической перезаписи старых 
//    сообщений в буфере без их внешнего сохранения. Буфер используется только 
//    один с общим размером, равным MinimumBuffers * BufferSize, а параметр 
//    MaximumBuffers не используется. Бит является взаимоисключающим со всеми 
//    остальными битами;  
// 2) EVENT_TRACE_REAL_TIME_MODE - режим передачи сообщений подключенным 
//    потребителям (т.н. режим реального времени). При отсутствии потребителей
//    сообщения теряются (до Windows Vista) или записываются во временный 
//    файл ограниченного размера (начиная с Windows Vista). В последнем случае 
//    при появлении потребителей им сначала будут переданы сообщения из 
//    временного файла и лишь затем сообщения из накопленных буферов. Указанный 
//    бит можно обьединять с битами 3)-6);  
// 3) EVENT_TRACE_FILE_MODE_NONE - режим последовательной записи в файл, при 
//    котором размер файла не ограничивается. Имя файла задается в параметре 
//    FileName. При наличии файла с указанным именем он будет перезаписан, если 
//    не указан бит EVENT_TRACE_FILE_MODE_APPEND. В последнем случае, записи 
//    будут добавляться в существующий файл;  
// 4) EVENT_TRACE_FILE_MODE_SEQUENTIAL - режим последовательной записи в файл, 
//    при котором запись завершается при достижении файлом максимального 
//    размера. Поступающие сообщения после этого отбрасываются. Имя файла 
//    задается в параметре FileName, а максимальный размер файла - в параметре 
//    MaxFileSize. При наличии файла с указанным именем он будет перезаписан, 
//    если не указан бит EVENT_TRACE_FILE_MODE_APPEND. В последнем случае, 
//    записи будут добавляться в существующий файл; 
// 5) EVENT_TRACE_FILE_MODE_CIRCULAR - режим циклической записи буферов в файл,
//    при котором при достижении файлом максимального размера новые сообщения 
//    будут перезаписывать старые. Имя файла задается в параметре FileName, 
//    а максимальный размер файла - в параметре MaxFileSize. При наличии файла 
//    с указанным именем он будет перезаписан; 
// 6) EVENT_TRACE_FILE_MODE_NEWFILE - режим последовательной записи в файл, при 
//    котором при достижении файлом максимального размера запись выполняется в 
//    новый файл с увеличением номера в имени файла. В данном режиме параметр 
//    FileName cодержит не точное имя файла, а его форматируемое имя (например, 
//    "c:\test%d.etl"). Максимальный размер файла задается в параметре 
//    MaxFileSize; 
// 
// В режимах последовательной записи 3)-4) при добавлении записей в файл 
// необходимо гарантировать, что параметры, влияющие на формат содержимого 
// файла, у сеанса, создавшего файл, совпадают с параметрами сеанса, 
// добавляющего записи в файл. Кроме того, отметка времени сообщения должна 
// быть системным (абсолютным) временем, в противном случае (при использовании 
// относительного времени) невозможно будет вычислить абсолютное время 
// возникновения события. При наличии максимального размера файла в режимах 
// 4)-6) можно также указать бит EVENT_TRACE_FILE_MODE_PREALLOCATE, который 
// заставляет ETW зарезервировать для файла пространство его максимального 
// размера на диске. При завершении сеанса размер файла будет уменьшен до 
// реального.   
// 
// По умолчанию отдельные процессоры выполняют запись сообщений (с отметкой 
// времени) в свой собственный буфер, поэтому при недостаточно точном 
// разрешении времени для сообщений из различных буферов с совпадающей 
// отметкой времени их запись в файлы или передача потребителям может быть 
// выполнена не в том порядке. Указание в параметре LogFileMode флага 
// EVENT_TRACE_NO_PER_PROCESSOR_BUFFERING (начиная с Windows 7) заставляет 
// различные процессоры писать в одни и те же буферы, что позволяет избежать 
// проблему некорректного порядка сообщений, но при этом снижается 
// быстродействие трассировки. 
// 
// По умолчанию буферы трассировки для сеансов 1)-4) выделяются из пула 
// невыгружаемой памяти, а для сеансов 5) - из пула выгружаемой памяти. 
// Для сеансов типа 4) (Event Tracing) указанное поведение можно изменить, 
// указав бит EVENT_TRACE_USE_PAGED_MEMORY в параметре LogFileMode. В таком 
// случае, сеансы Event Tracing теряют возможность приема сообщений из режима
// ядра.  
// 
///////////////////////////////////////////////////////////////////////////////
// Провайдеры Managed Object Format
///////////////////////////////////////////////////////////////////////////////
// В пользовательском режиме регистрация MOF-провайдеров трассировки 
// производится функцией RegisterTraceGuids, а отмена регистрации - функцией 
// UnregisterTraceGuids. При регистрации провайдера указывается адрес функции 
// обратного вызова WMIDPREQUEST, которая вызывается при возникновении событий, 
// связанных с провайдером. 
// 
// В режиме ядра до Windows Vista SP1 регистрация и отмена регистрации 
// MOF-провайдеров трассировки в драйверах производится функцией 
// IoWMIRegistrationControl с указанием недокументированных флагов 
// WMIREG_FLAG_CALLBACK и WMIREG_FLAG_TRACE_PROVIDER. Первый флаг указывает, 
// что первым параметром функции IoWMIRegistrationControl будет функция 
// обратного вызова, а не объект драйвера (PDRIVER_OBJECT). Второй параметр
// определяет назначение и прототип функции обратного вызова, которая 
// вызывается при возникновении событий, связанных с провайдером. В данном 
// случае, прототипом функции обратного вызова является
// typedef LONG (*WMIENTRY_NEW)(
//      IN UCHAR MinorFunction,      // код события
//      IN PVOID DataPath OPTIONAL,  // не используется
//      IN ULONG BufferLength,       // размер буфера
//      IN OUT PVOID Buffer,         // буфер входных и выходных данных
//      IN PVOID Context,            // связанный контест 
//      OUT PULONG Size              // размер выходных данных
// );
// Начиная с Windows Vista SP1 в режиме ядра регистрация провайдеров трассировки 
// производится функцией EtwRegisterClassicProvider, а отмена регистрации - 
// функцией EtwUnregister. При регистрации провайдера указывается адрес функции 
// обратного вызова ETW_CLASSIC_CALLBACK, которая вызывается при возникновении 
// событий, связанных с провайдером. 
// 
// Генерация событий в MOF-провайдерах осуществляется функциями IoWMIWriteEvent 
// (в режиме ядра) и TraceEvent (в пользовательском режиме). 
// 
// Кроме того, MOF-провайдеры могут генерировать текстовые сообщения при помощи 
// функций WmiTraceMessageVa/WmiTraceMessage (в режиме ядра) и 
// TraceMessageVa/TraceMessage (в пользовательском режиме). Текстовые 
// сообщения, генерируемые MOF-провайдером, идентифицируются парой (GUID, ID), 
// где GUID - уникальный идентификатор источника сообщения, а ID - 
// идентификатор сообщения в источнике. При генерации текстового сообщения 
// провайдером трассировки с ним можно связать переменное число параметров, 
// передаваемых без указания типа в виде пар (адрес, размер). Кроме того, c 
// каждым текстовым сообщением, переданным MOF-провайдером с опцией 
// TRACE_MESSAGE_SEQUENCE сеанс может сопоставить специальный последовательный 
// номер, который будет уникальным для всех сеансов, если в параметре 
// LogFileMode сеанса установлен флаг EVENT_TRACE_USE_GLOBAL_SEQUENCE, или 
// уникальным только в рамках данного сеанса, если установлен флаг 
// EVENT_TRACE_USE_LOCAL_SEQUENCE. Способ поиска сообщения по паре (GUID, ID)
// выходит за рамки ETW и определяется инструментальными средствами на свое 
// усмотрение. Ниже будет описан такой способ для трассировки WPP. 
// 
///////////////////////////////////////////////////////////////////////////////
// Трассировка Windows Preprocessor Software Tracing (WPP)
///////////////////////////////////////////////////////////////////////////////
// Трассировка WPP основывается на трассировке ETW, в реализации которой 
// уточняются интерпретация параметров EnableFlag и EnableLevel провайдерами 
// трассировки и способ формирование сообщений по (GUID, ID). Кроме того, 
// трассировка WPP позволяет только одному сеансу принимать сообщения от 
// отдельного провайдера трассировки. 
// 
// Каждый провайдер трассировки WPP имеет дружественное имя, GUID и 
// поддерживаемые категории сообщений, каждая из которых имеет собственное 
// имя. Каждое сообщение трассировки, идентифицируемые парой (GUID, ID), 
// содержит следующие компоненты: строку форматирования, описание типов 
// передаваемых параметров, категорию и/или степень важности. 
// 
// В трассировке WPP параметр EnableFlag определяет допустимые категории 
// сообщений, а параметр EnableLevel - допустимую степень важности сообщений.
// Форматирование сообщений по (GUID, ID) происходит следующим образом: 
// 1) по GUID определяется имя TMF-файла описания сообщений источника (в 
//    качестве источника используется отдельный файл исходного кода, в 
//    котором расположены вызовы функций TraceMessageVa и TraceMessage); 
// 2) по ID из TMF-файла извлекаются компоненты сообщения;
// 3) форматирование сообщений определяется на основе строки форматирования, 
//    типов и значений передаваемых параметров по специальными правилам, 
//    которые будут описаны ниже. 
// Кроме того, при трассировке WPP создаются TMC-файлы, которые содержат 
// описания используемых провайдеров трассировки: дружественное имя, GUID и 
// поддерживаемые категории сообщений. TMF-и TMC-файлы позволяют утилите 
// TraceView создавать сеансы трассировки, настраивать допустимые в сеансе
// провайдеры и проводить фильтрацию сообщений по категории и/или степени 
// важности. 
//
// Состояние отдельного провайдера трассировки WPP описывается структурой
// WPP_TRACE_CONTROL_BLOCK, за которой следует дополнительное пространство, 
// используемое в качестве расширения поля Flags (если категорий сообщений 
// больше 32). 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 0, то 
// оставшиеся поля структуры имеют следующее значения: 
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Logger               - описатель сеанса, связанного с провайдером; 
// FlagsLen             - размер буфера Flags в 32-разрядных элементах; 
// Level                - допустимая степень важности сообщений провайдера в сеансе; 
// Flags                - битовая маска допустимых категорий сообщений провайдера в сеансе; 
// ControlGuid          - адрес GUID провайдера. 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_WIN2K_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Win2kCb              - адрес структуры WPP_WIN2K_CONTROL_BLOCK, поля которой имеют следующее значение: 
//      Logger          - описатель сеанса, связанного с провайдером; 
//      Flags           - битовая маска допустимых категорий сообщений провайдера в сеансе; 
//      Level           - допустимая степень важности сообщений провайдера в сеансе; 
//      ControlGuid     - адрес GUID провайдера; 
// FlagsLen             - не используется (отсутствовало в Windows 2000); 
// Level                - не используется (отсутствовало в Windows 2000); 
// Flags                - не используется (отсутствовало в Windows 2000); 
// ControlGuid          - не используется (отсутствовало в Windows 2000). 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_WHISTLER_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// Next                 - адрес структуры следующего зарегистрированного провайдера трассировки; 
// UmRegistrationHandle - описатель провайдера, возвращаемый функцией RegisterTraceGuids; 
// Cb                   - адрес структуры WPP_TRACE_CONTROL_BLOCK, поля которой имеют следующее значение: 
//      Next                 - может использоваться на усмотрение провайдера; 
//      UmRegistrationHandle - может использоваться на усмотрение провайдера; 
//      Logger               - описатель сеанса, связанного с провайдером; 
//      FlagsLen             - размер буфера Flags в 32-разрядных элементах; 
//      Level                - допустимая степень важности сообщений провайдера в сеансе; 
//      Flags                - битовая маска допустимых категорий сообщений провайдера в сеансе; 
//      ControlGuid          - адрес GUID провайдера; 
// FlagsLen             - может использоваться на усмотрение провайдера; 
// Level                - может использоваться на усмотрение провайдера; 
// Flags                - может использоваться на усмотрение провайдера; 
// ControlGuid          - адрес GUID провайдера. 
// 
// Если поле Options структуры WPP_TRACE_CONTROL_BLOCK имеет значение 
// WPP_VER_LH_CB_FORWARD_PTR, то оставшиеся поля структуры имеют следующее значения:
// 
// 
// 
// 
// typedef struct _WPP_TRACE_CONTROL_BLOCK {
//     struct _WPP_TRACE_CONTROL_BLOCK* Next;
//     TRACEHANDLE     UmRegistrationHandle;
//     union {
//         TRACEHANDLE              Logger;
//         PWPP_WIN2K_CONTROL_BLOCK Win2kCb;
//         PVOID                    Ptr;
//         struct _WPP_TRACE_CONTROL_BLOCK *Cb;
//     } u;
//     UCHAR           FlagsLen;
//     UCHAR           Level;
//     USHORT          Options;
//     ULONG           Flags[1];
//     LPCGUID         ControlGuid;
// } WPP_TRACE_CONTROL_BLOCK, *PWPP_TRACE_CONTROL_BLOCK;
// 
// 
// 
// 
// 
// 
// При использовании WPP трассировка сообщений (событий) производится 
// провайдерами трассировки. Каждый провайдер трассировки имеет дружественное 
// имя, GUID и поддерживаемые категории сообщений, каждая из которых имеет 
// собственное имя. Определение 
// провайдеров трассировки производится внутри макроса WPP_CONTROL_GUIDS с 
// использованием макроса WPP_DEFINE_CONTROL_GUID. Провайдеры трассировки, 
// задействованные в статических библиотеках, необходимо также указывать 
// в макросе WPP_CONTROL_GUIDS исполняемых модулей (.exe, .dll), использующих
// указанные библиотеки. 
// 
// Параметры, передаваемые макросу WPP_DEFINE_CONTROL_GUID(Name, Guid, Bits), 
// имеют следующий смысл: 
// Name - дружественное имя провайдера трассировки; 
// Guid - GUID провайдера трассировки, передаваемый в виде 
//        (xxxxxxxx,xxxx,xxxx,xxxx,xxxxxxxxxxxx); 
// Bits - имена категорий сообщений, передаваемые в виде 
//        WPP_DEFINE_BIT(Name1) ... WPP_DEFINE_BIT(NameN). 
// 
// Например, определение макроса WPP_CONTROL_GUIDS может выглядеть следующим 
// образом: 
// #define WPP_CONTROL_GUIDS                                \
//      WPP_DEFINE_CONTROL_GUID(                            \
//        Regular, (81b20fea,73a8,4b62,95bc,354477c97a6f),  \
//        WPP_DEFINE_BIT(Error)                             \
//        WPP_DEFINE_BIT(Unusual)                           \
//        WPP_DEFINE_BIT(Noise)                             \
//     )                                                    \
//     WPP_DEFINE_CONTROL_GUID(                             \
//        HiFreq, (91b20fea,73a8,4b62,95bc,354477c97a6f),   \
//        WPP_DEFINE_BIT(Entry)                             \
//        WPP_DEFINE_BIT(Exit)                              \
//        WPP_DEFINE_BIT(ApiCalls)                          \
//        WPP_DEFINE_BIT(RandomJunk)                        \
//        WPP_DEFINE_BIT(LovePoem)                          \
//     )




// 
// Инициализация провайдера трассировки. 
///////////////////////////////////////////////////////////////////////////////
// 
// 
// 
// При нахождении в исходном файле специального выражения WPP_INIT_TRACING
// утилита TraceWpp генерирует thm-файл, 
// 
// 
//     WPP_DEFINE_CONTROL_GUID(Regular,(81b20fea,73a8,4b62,95bc,354477c97a6f), \
//       WPP_DEFINE_BIT(Error)      \
//       WPP_DEFINE_BIT(Unusual)    \
//       WPP_DEFINE_BIT(Noise)      \
//    )        \
//    WPP_DEFINE_CONTROL_GUID(HiFreq,(91b20fea,73a8,4b62,95bc,354477c97a6f), \
//       WPP_DEFINE_BIT(Entry)      \
//       WPP_DEFINE_BIT(Exit)       \
//       WPP_DEFINE_BIT(ApiCalls)   \
//       WPP_DEFINE_BIT(RandomJunk) \
//       WPP_DEFINE_BIT(LovePoem)   \
//    )
// 
// 
// #define WPP_EVAL(x) x                            // подстановка аргумента после его раскрытия
// #define WPP_STR(x)  #x                           // создание ANSI-литерала без раскрытия аргумента
// #define WPP_STRINGIZE(x) WPP_STR(x)              // создание ANSI-литерала c раскрытием аргумента
// 
// #define WPP_GLUE(a, b)  a ## b                           // обьединение двух аргументов без раскрытия
// #define WPP_GLUE3(a, b, c)  a ## b ## c                  // обьединение трех аргументов без раскрытия
// #define WPP_GLUE4(a, b, c, d)  a ## b ## c ## d          // обьединение четырех аргументов без раскрытия
// #define WPP_XGLUE(a, b) WPP_GLUE(a, b)                   // обьединение двух аргументов c раскрытием
// #define WPP_XGLUE3(a, b, c) WPP_GLUE3(a, b, c)           // обьединение трех аргументов c раскрытием
// #define WPP_XGLUE4(a, b, c, d) WPP_GLUE4(a, b, c, d)     // обьединение четырех аргументов c раскрытием
// 
// #define _WPPW(x) WPP_GLUE(L, x)                          // обьединение L c аргументом c раскрытием
// 
// обьединение пяти аргументов без раскрытия
// #define WPP_GUID_NORM(l,w1,w2,w3,ll) l ## w1 ## w2 ## w3 ## ll   
//             
// создание ANSI-литерала из пяти аргументов без раскрытия
// #define WPP_GUID_TEXT(l,w1,w2,w3,ll) #l "-" #w1 "-" #w2 "-" #w3 "-" #ll      
// 
// создание Unicode-литерала из пяти аргументов без раскрытия
// #define WPP_GUID_WTEXT(l,w1,w2,w3,ll) _WPPW(#l) L"-" _WPPW(#w1) L"-" _WPPW(#w2) L"-" _WPPW(#w3) L"-" _WPPW(#ll)
//
// извлечение байта из аргумента без раскрытия
// #define WPP_EXTRACT_BYTE(val,n) (((ULONGLONG)(0x ## val) >> (8 * n)) & 0xFF)
// 
// создание значения GUID из аргументов без раскрытия
// #define WPP_GUID_STRUCT(l,w1,w2,w3,ll) {0x ## l, 0x ## w1, 0x ## w2,\
//     {WPP_EXTRACT_BYTE(w3, 1), WPP_EXTRACT_BYTE(w3, 0),\
//      WPP_EXTRACT_BYTE(ll, 5), WPP_EXTRACT_BYTE(ll, 4),\
//      WPP_EXTRACT_BYTE(ll, 3), WPP_EXTRACT_BYTE(ll, 2),\
//      WPP_EXTRACT_BYTE(ll, 1), WPP_EXTRACT_BYTE(ll, 0)} }
//
// объединение WPP_CTL_ c раскрытым Name
// #define WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) WPP_XGLUE(WPP_CTL_, WPP_EVAL(Name)),
// enum WPP_CTL_NAMES { WPP_CONTROL_GUIDS WPP_LAST_CTL};  -> 
//      enum WPP_CTL_NAMES { WPP_CTL_Regular, WPP_CTL_HiFreq, WPP_LAST_CTL };
// #undef WPP_DEFINE_CONTROL_GUID

// #define WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) \
// extern __declspec(selectany) const GUID WPP_XGLUE4(WPP_, ThisDir, _CTLGUID_, WPP_EVAL(Name)) = WPP_GUID_STRUCT Guid;
// WPP_CONTROL_GUIDS -> 
//  extern __declspec(selectany) const GUID WPP_<ThisDir>_CTLGUID_Regular = 
//      {0x81b20fea, 0x73a8, 0x4b62, { 
//          (((ULONGLONG)(0x95bc        ) >> (8 * 1)) & 0xFF), 
//          (((ULONGLONG)(0x95bc        ) >> (8 * 0)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 5)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 4)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 3)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 2)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 1)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 0)) & 0xFF)
//      };  
//  extern __declspec(selectany) const GUID WPP_<ThisDir>_CTLGUID_HiFreq = 
//      {0x91b20fea, 0x73a8, 0x4b62, { 
//          (((ULONGLONG)(0x95bc        ) >> (8 * 1)) & 0xFF), 
//          (((ULONGLONG)(0x95bc        ) >> (8 * 0)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 5)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 4)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 3)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 2)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 1)) & 0xFF), 
//          (((ULONGLONG)(0x354477c97a6f) >> (8 * 0)) & 0xFF)
//      };  
// #undef WPP_DEFINE_CONTROL_GUID
// 
// #define WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) \
//     WPP_XGLUE(WPP_BLOCK_START_, WPP_EVAL(Name)) = WPP_XGLUE(WPP_CTL_, WPP_EVAL(Name)) * 0x10000, Bits WPP_XGLUE(WPP_BLOCK_END_, WPP_EVAL(Name)),
// #define WPP_DEFINE_BIT(Name) WPP_BIT_ ## Name,
// enum WPP_DEFINE_BIT_NAMES { WPP_CONTROL_GUIDS }; ->
//      enum WPP_DEFINE_BIT_NAMES {  
//          WPP_BLOCK_START_Regular = WPP_CTL_Regular * 0x10000, 
//          WPP_BIT_Error, WPP_BIT_Unusual, WPP_BIT_Noise,
//          WPP_BLOCK_END_Regular,
//          WPP_BLOCK_START_HiFreq = WPP_CTL_HiFreq * 0x10000, 
//          WPP_BIT_Entry, WPP_BIT_Exit, WPP_BIT_ApiCalls, WPP_BIT_RandomJunk, WPP_BIT_LovePoem,
//          WPP_BLOCK_END_HiFreq,
//      }; 
// #undef WPP_DEFINE_BIT
// #undef WPP_DEFINE_CONTROL_GUID
//
// #define WPP_MASK(CTL)    (1 << ( ((CTL)-1) & 31 ))       // маска из CTL младших битов
// #define WPP_FLAG_NO(CTL) ( (0xFFFF & ((CTL)-1) ) / 32)   // 
// #define WPP_CTRL_NO(CTL) ((CTL) >> 16)                   // 
// 
// calculate how many DWORDs we need to get the required number of bits
// upper estimate. Sometimes will be off by one
// #define WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) | WPP_XGLUE(WPP_BLOCK_END_, WPP_EVAL(Name))
// enum _WPP_FLAG_LEN_ENUM { WPP_FLAG_LEN = 1 | ((0 WPP_CONTROL_GUIDS) & 0xFFFF) / 32 }; -> 
//      enum _WPP_FLAG_LEN_ENUM { WPP_FLAG_LEN = 1 | ((0 | WPP_BLOCK_END_WPP_Regular | WPP_BLOCK_END_WPP_HiFreq) & 0xFFFF) / 32 }; -> 
// #undef WPP_DEFINE_CONTROL_GUID

//
// Check that maximum number of flags does not exceed 32
//
//#ifndef C_ASSERT
//#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
//#endif

//#define MAX_NUMBER_OF_ETW_FLAGS 34 // 32 flags plus 2 separators
//#define WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) && ((WPP_XGLUE(WPP_BLOCK_END_, WPP_EVAL(Name) & 0xFFFF)) < MAX_NUMBER_OF_ETW_FLAGS)
// enum _WPP_FLAG_LEN_ENUM_MAX { WPP_MAX_FLAG_LEN_CHECK = (1 WPP_CONTROL_GUIDS) }; ->
//  enum _WPP_FLAG_LEN_ENUM_MAX { WPP_MAX_FLAG_LEN_CHECK = (1  
//      && ((WPP_BLOCK_END_Regular & 0xFFFF) < MAX_NUMBER_OF_ETW_FLAGS) 
//      && ((WPP_BLOCK_END_HiFreq  & 0xFFFF) < MAX_NUMBER_OF_ETW_FLAGS) 
//  }; ->
//#undef WPP_DEFINE_CONTROL_GUID
//
// typedef union {
//    WPP_TRACE_CONTROL_BLOCK Control;
//    UCHAR ReserveSpace[ sizeof(WPP_TRACE_CONTROL_BLOCK) + sizeof(ULONG) * (WPP_FLAG_LEN - 1) ];
//} WPP_CB_TYPE ;

//

// раскрывается в 
// 

#pragma once
///////////////////////////////////////////////////////////////////////////////
// Определение nullptr (отсутствовал в С++ до Visual Studio 2012)
///////////////////////////////////////////////////////////////////////////////
#if defined _MSC_VER && _MSC_VER < 1700
#if !defined _MANAGED || _MANAGED == 0
#define nullptr 0
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
// Стандартные определения трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined _WIN32
#include <wmistr.h>                     // определения WMI
#include <evntrace.h>                   // определения ETW
#else 
#define TRACE_LEVEL_NONE            0   // отсутствие трассировки
#define TRACE_LEVEL_CRITICAL        1   // критическая ошибка
#define TRACE_LEVEL_ERROR           2   // ошибка
#define TRACE_LEVEL_WARNING         3   // предупреждение
#define TRACE_LEVEL_INFORMATION     4   // информация
#define TRACE_LEVEL_VERBOSE         5   // детализированная информация
#endif 

///////////////////////////////////////////////////////////////////////////////
// Определение имени функции
///////////////////////////////////////////////////////////////////////////////
#if defined _MSC_VER
#define WPP_FUNC    __FUNCSIG__
#else 
#define WPP_FUNC    __func__
#endif 

///////////////////////////////////////////////////////////////////////////////
// Запрет встраивания функций
///////////////////////////////////////////////////////////////////////////////
#if defined _MSC_VER
#define WPP_NOINLINE        __declspec(noinline)
#else 
#define WPP_NOINLINE        __attribute__((noinline)) 
#endif 

///////////////////////////////////////////////////////////////////////////////
// Создание литеральной строки. WPP_STRINGIZE(x) нельзя определить как #x, 
// поскольку при использовании # не производится раскрытия аргумента. Например, 
// в этом случае WPP_STRINGIZE(OTHER_MACRO(x)) перешло бы в "OTHER_MACRO(x)", 
// а не в строковое значение раскрытого OTHER_MACRO(x).
///////////////////////////////////////////////////////////////////////////////
#define WPP_STR(      x)          # x
#define WPP_STRINGIZE(x)    WPP_STR(x)

///////////////////////////////////////////////////////////////////////////////
// Создание уникального имени переменной. WPP_VAR(LINE) нельзя определить как
// Trace ## LINE, поскольку при использовании ## не производится раскрытия 
// аргумента. Например, WPP_VAR(__LINE__) перешло бы в Trace__LINE__, а не в 
// TraceXXX, где XXX - номер строки (результат раскрытия макроса __LINE__)
///////////////////////////////////////////////////////////////////////////////
#define WPP_GLUE(x, y)      x ## y
#define WPP_VAR(LINE )      WPP_GLUE(Trace, LINE)

///////////////////////////////////////////////////////////////////////////////
// Настройка провайдера трассировки. Провайдер трассировки определяется 
// макросом WPP_DEFINE_CONTROL_GUID, который должен присутствовать в 
// определении специального макроса WPP_CONTROL_GUIDS. Параметрами макроса 
// WPP_DEFINE_CONTROL_GUID выступают дружественное имя провайдера, его 
// GUID-идентификатор, а также имена битов, определяющих различные категории 
// трассировки. Поскольку мы используем уровень важности сообщений трассировки, 
// а не их категории, то все сообщения трассировки будем относить к одной и той 
// же категории ALL (бит 0). В определении макроса WPP_CONTROL_GUIDS также 
// следует включить определения провайдеров трассировки, задействованных в 
// используемых статических библиотеках. 
///////////////////////////////////////////////////////////////////////////////
#if !defined WPP_CONTROL_NAME
#error [Trace.h] The WPP_CONTROL_NAME should be defined prior to including Trace.h
#endif

#define ThisDir WPP_CONTROL_NAME

// Строковое представление имени провайдера
#define WPP_COMPNAME WPP_STRINGIZE(WPP_CONTROL_NAME)

// Определение провайдеров для статических библиотек
#if !defined WPP_STATIC_LIB_GUIDS
#define WPP_STATIC_LIB_GUIDS
#endif 

// Определение идентификаторов трассировки
#if defined WPP_CONTROL_GUID
#define WPP_CONTROL_GUIDS                                           \
    WPP_DEFINE_CONTROL_GUID(WPP_CONTROL_NAME, WPP_CONTROL_GUID,     \
        WPP_DEFINE_BIT(ALL)                                         \
    )                                                               \
    WPP_STATIC_LIB_GUIDS
#endif

///////////////////////////////////////////////////////////////////////////////
// Дополнительно используемые файлы
///////////////////////////////////////////////////////////////////////////////
#include <stdarg.h>         // функции с переменным числом аргументов
#include <string.h>         // строковые функции 

#if !defined _NTDDK_
#include <stdlib.h>         // функции общего назначения
#include <string>           // строковые функции C++
#if _HAS_CXX17 == 1
#include <string_view>      // строковое расширение C++17
#endif
#if defined _WIN32
#include <winternl.h>		// дополнительные определения Windows 
#include <sddl.h>			// система безопасности Windows
#include <objbase.h>        // определения COM
#endif 
#if defined __linux__
#include <unistd.h>         // определения Unix
#include <pthread.h>        // информация потоков
#endif 
#endif 

///////////////////////////////////////////////////////////////////////////////
// Указание правильного соглашения о вызове функции TraceMessageVa. 
// В некоторых версиях файла evntrace.h stdcall-функция TraceMessageVa 
// объявлена без указания соглашения о вызове, что при использовании 
// компилятором по умолчанию соглашения __cdecl приводит к формированию 
// неправильного декорированного имени функции и нарушению стека при 
// выполнении функции. 
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS && !defined _NTDDK_
#if defined _MSC_VER && !defined _WIN64
#pragma comment(linker, "/alternatename:_TraceMessageVa=_TraceMessageVa@24")

// указать правильный прототип функции
typedef ULONG (WINAPI *PFN_TRACE_MESSAGE_VA)(TRACEHANDLE, ULONG, LPCGUID, USHORT, va_list);

// вызвать функцию трассировки
inline ULONG WINAPI CallTraceMessageVa(TRACEHANDLE LoggerHandle,
    ULONG MessageFlags, LPCGUID MessageGuid, USHORT MessageNumber, va_list MessageArgList)
{
    // выполнить преобразование типа
    PFN_TRACE_MESSAGE_VA pfn = (PFN_TRACE_MESSAGE_VA)::TraceMessageVa; 

    // выполнить трассировку
    return (*pfn)(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, MessageArgList); 
}
#else 
// вызвать функцию трассировки
inline ULONG WINAPI CallTraceMessageVa(TRACEHANDLE LoggerHandle,
    ULONG MessageFlags, LPCGUID MessageGuid, USHORT MessageNumber, va_list MessageArgList)
{
    // выполнить трассировку
    return ::TraceMessageVa(LoggerHandle, MessageFlags, (LPGUID)MessageGuid, MessageNumber, MessageArgList); 
}
#endif 
#endif

// Во избежание дублирования определения компонентов в .tmc-файлах при сборке
// Release-версии необходимо удалять неиспользуемые символы через опцию 
// связывания /OPT:REF. 

///////////////////////////////////////////////////////////////////////////////
// Трассировка строк фиксированного размера (см. TraceFormat.h)
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(.*s , WPP_LOGCPPVEC, const trace::_str &, ItemPString,  "s",  str, 0);
// DEFINE_CPLX_TYPE(.*hs, WPP_LOGCPPVEC, const trace::_str &, ItemPString,  "s",  str, 0);
// DEFINE_CPLX_TYPE(.*ls, WPP_LOGCPPVEC, const trace::_wstr&, ItemPWString, "s", wstr, 0);
// DEFINE_CPLX_TYPE(.*ws, WPP_LOGCPPVEC, const trace::_wstr&, ItemPWString, "s", wstr, 0);
// end_wpp

namespace trace { 
class _str { private: const char* _sz; size_t _cch;
    
    // конструктор
    public: _str(const char* sz, size_t cch) : _sz(sz), _cch(cch) {} 

    // адрес строки
    public: const char* data() const { return _sz; }

    // размер строки
    public: size_t size() const { return _cch; }
};
class _wstr { private: const wchar_t* _sz; size_t _cch;
    
    // конструктор
    public: _wstr(const wchar_t* sz, size_t cch) : _sz(sz), _cch(cch) {}

    // адрес строки
    public: const wchar_t* data() const { return _sz; }

    // размер строки
    public: size_t size() const { return _cch; }
};
}

///////////////////////////////////////////////////////////////////////////////
// Параметры трассировки (переменные окружения)
///////////////////////////////////////////////////////////////////////////////
#if !defined _NTDDK_
namespace trace {
extern std::string GetEnvironmentVariable(const char*);
class ControlParameters
{ 
	// конструктор
	public: ControlParameters() { Update(); } private: std::string prefix;

    // обновить значения переменных
    public: void Update() { prefix = GetEnvironmentVariable("TRACE_FORMAT_PREFIX"); }
	// значение префикса
	public: const char* DebugPrefix() const 
	{ 
		// значение префикса
		return (prefix.length() != 0) ? prefix.c_str() : nullptr; 
	}
};
#if !defined WPP_CONTROL_GUIDS 
inline const ControlParameters* GetControlParameters() 
{ 
	// получить способ записи префикса
	static ControlParameters parameters; return &parameters;
}
#else 
// получить параметры трассировки
const ControlParameters* GetControlParameters(); 
#endif 
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Включаемые заголовочные файлы
///////////////////////////////////////////////////////////////////////////////
#if !defined _NTDDK_
#include "TraceUTF.h"       // преобразование кодировок
#endif 
#include "TraceFormat.h"    // форматирование строк
#include "TraceDebug.h"     // вывод сообщений в отладчик

///////////////////////////////////////////////////////////////////////////////
// Предварительное объявление функций
///////////////////////////////////////////////////////////////////////////////
void WppTraceStringA(int level, const char   * sz, size_t cch = -1); 
void WppTraceStringW(int level, const wchar_t* sz, size_t cch = -1); 

///////////////////////////////////////////////////////////////////////////////
// Вывод сообщения в отладчик. Служебная информация WPP выводится при 
// помощи макроса WppDebug(n, MsgArgs), где n - внутренний номер, а 
// MsgArgs - заключенные в круглые скобки строка форматирования и ее 
// параметры. В используемой реализации указанная информация будет 
// передаваться отладчику с уровнем трассировки TRACE_LEVEL_INFORMATION. 
///////////////////////////////////////////////////////////////////////////////
inline void WppDebugPrintV(int level, const char* szFile, 
    int line, const char* szFunction, const char* szFormat, va_list& args)
{
    // отменить удаление неиспользуемых функций
    void (*pfnA)(int, const char   *, size_t) = &WppTraceStringA; (*pfnA)(0, nullptr, 0); 
    void (*pfnW)(int, const wchar_t*, size_t) = &WppTraceStringW; (*pfnW)(0, nullptr, 0);

#if !defined _NTDDK_ && defined WPP_CONTROL_GUIDS
	// проверить необходимость вывода
	if (level == TRACE_LEVEL_VERBOSE) return; 
#endif 
	// проверить необходимость вывода
	if (level == TRACE_LEVEL_NONE) return; 

    // передать сообщение отладчику
    trace::DebugPrintV(WPP_COMPNAME, "ALL", level, 
        szFile, line, szFunction, false, szFormat, args
	); 
}

inline void WppDebugPrint(int level, const char* szFile, 
    int line, const char* szFunction, const char* szFormat, ...)
{
    // перейти на переменное число параметров
    va_list args; va_start(args, szFormat); 

    // передать сообщение отладчику
	WppDebugPrintV(level, szFile, line, szFunction, szFormat, args); 	

	// освободить выделенные ресурсы
	va_end(args);
}
// добавление фиксированных параметров 
#define WPP_DEBUG_PRINT(...)	WppDebugPrint(	\
	TRACE_LEVEL_INFORMATION,                    \
	__FILE__, __LINE__, WPP_FUNC, __VA_ARGS__	\
)
// перенаправление служебной информации
#define WppDebug(n, MsgArgs) WPP_DEBUG_PRINT MsgArgs

///////////////////////////////////////////////////////////////////////////////
// Выполнение любой трассировки вида ATRACE(TRACELEVEL,...,MSG,...) определяется 
// следующим алгоритмом: 
// WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_<XXX>(...), MSG,...)
// WPP_TRACELEVEL_<XXX>_PRE(TRACELEVEL, ...)
// ((
//     WPP_TRACELEVEL_<XXX>_ENABLED(TRACELEVEL, ...)
//     ? WPP_INVOKE_WPP_DEBUG((MSG,...)), WPP_SF_<SIG>(...), 1 : 0
// ))
// WPP_TRACELEVEL_<XXX>_POST(TRACELEVEL, ...)
///////////////////////////////////////////////////////////////////////////////
// 1) Макрос WPP_LOG_ALWAYS используется для дополнительного вывода сообщений 
//    в отладчик. Ему передаются все параметры, возвращаемые макросом
//    WPP_EX_TRACELEVEL_<XXX>, а также строка форматирования и ее аргументы. 
//    Параметры, возвращаемые макросом WPP_EX_TRACELEVEL_<XXX>, используются 
//    для проверки необходимости вывода сообщений, а также определения уровня 
//    трассировки, используемого в отладчике. Если переданный уровень равен 
//    TRACE_LEVEL_NONE, то вывод в отладчик не производится. В противном случае, 
//    a) в режиме ядра вывод в отладчик осуществляется в соответствии со 
//       следующей таблицей: 
//       TRACE_LEVEL_CRITICAL    -> DPFLTR_ERROR_LEVEL;
//       TRACE_LEVEL_ERROR       -> DPFLTR_ERROR_LEVEL;
//       TRACE_LEVEL_WARNING     -> DPFLTR_WARNING_LEVEL;
//       TRACE_LEVEL_INFORMATION -> DPFLTR_INFO_LEVEL;
//       TRACE_LEVEL_VERBOSE     -> DPFLTR_TRACE_LEVEL;
//    b) в режиме пользователя уровень трассировки игнорируется и вывод 
//       в отладчик производится всегда, за исключением уровня 
//       TRACE_LEVEL_VERBOSE при наличии ETW-трассировки. 
// 2) Макрос WPP_EX_TRACELEVEL_<XXX>, как уже сказано выше, предназначен 
//    для передачи дополнительных параметров макросу WPP_LOG_ALWAYS. Среди 
//    указанных параметров должен быть уровень трассировки, используемый 
//    в отладчике. 
// 3) Макрос WPP_TRACELEVEL_<XXX>_PRE предназначен для выполнения 
//    дополнительных предварительных действий до непосредственного момента 
//    трассировки. 
// 4) Макрос WPP_TRACELEVEL_<XXX>_ENABLED проверяет необходимость 
//    выполнения трассировки (например, соответствие уровня трассировки 
//    используемому уровню трассировки в сеансе). 
// 5) Макрос WPP_INVOKE_WPP_DEBUG выполняется только отладочном режиме 
//    непосредственно перед трассировкой, принимает в качестве параметров 
//    строку форматирования и ее аргументы и определяется через макрос 
//    WPP_DEBUG. Если макрос WPP_DEBUG не определен, то макрос 
//    WPP_INVOKE_WPP_DEBUG ничего не выполняет. 
// 6) Функция WPP_SF_<SIG> является оберточной функцией для макроса 
//    трассировки WPP_TRACE, который непосредственно и выполняет 
//    трассировку параметров. По умолчанию в режиме пользователя
//    макрос WPP_TRACE раскрывается в вызов функции TraceMessage. 
// 7) Макрос WPP_TRACELEVEL_<XXX>_POST предназначен для выполнения 
//    дополнительных завершающих действий. 
///////////////////////////////////////////////////////////////////////////////
// Замечания к реализации. 
///////////////////////////////////////////////////////////////////////////////
// 1) Поскольку строка форматирования и ее аргументы во всех версиях продукта
//    (Debug и Release) передаются только макросу WPP_LOG_ALWAYS, то 
//    вывод в отладчик отфоматированной строки может быть только при 
//    выполнении макроса WPP_LOG_ALWAYS (вариант сохранения параметров 
//    в макросе WPP_LOG_ALWAYS не рассматривается, поскольку для такой 
//    реализации потребуется шаблонный класс с переменным числом параметров, 
//    что не поддерживается в старых версиях Visual Studio, например, VS 2008). 
// 2) Поскольку при проверке отсутствия ошибок среди аргументов функции 
//    форматирования присутствует аргумент признака (кода) ошибки, который 
//    может раскрываться в вызов функции, то макрос WPP_LOG_ALWAYS должен 
//    сохранить его во временной переменной для последующего использования 
//    указанной временной переменной, а не повторного раскрытия макроса, 
//    приводящего к новому вызову функции. 
// 3) Для проверки необходимости вывода отформатированного сообщения в 
//    отладчик макросу WPP_LOG_ALWAYS должна передаваться функция или 
//    другой макрос проверки допустимости вывода (например, макрос
//    WPP_TRACELEVEL_<XXX>_ENABLED). В текущей реализации это выполняется 
//    передачей макросу WPP_LOG_ALWAYS макроса проверки допустимости, 
//    который будет однократно вызван внутри макроса WPP_LOG_ALWAYS.
// 4) Объединяя п.1)-3), макрос WPP_EX_TRACELEVEL_<XXX> должен передать 
//    макросу WPP_LOG_ALWAYS как минимум 4 параметра: 
//    a) тип переменной, в которой должен сохраняться однократно 
//       вычисляемый аргумент (код или признак ошибки); 
//    b) значение однократно вычисляемого аргумента; 
//    с) имя макроса, проверяющего допустимость вывода; 
//    d) уровень трассировки, выполняемой отладчиком. 
// 5) Если в качестве результата макроса WPP_EX_TRACELEVEL_<XXX> указать 
//    упомянутые параметры через запятую без дополнительных разделителей, 
//    то компилятор Microsoft ошибочно (не в соответствии со стандартом) 
//    не "распакует" результат в последовательные параметры макроса 
//    WPP_LOG_ALWAYS, а в "упакованном" виде весь результат (т.е. все 
//    параметры) передаcт на место первого параметра макроса. Поэтому 
//    для возможности использования указанных параметров применяется 
//    следующий совместимый со стандартом метод: 
//    a) макрос WPP_EX_TRACELEVEL_<XXX> возвращает указанные параметры в 
//       круглых скобках (что дополнительно наглядно группирует параметры); 
//    b) определяются 4 макросные функции извлечения параметров: 
//       #define WPP_LOG_EXTRACT_TYPE( TYPE, VALUE, CHECK, LEVEL) TYPE
//       #define WPP_LOG_EXTRACT_VALUE(TYPE, VALUE, CHECK, LEVEL) VALUE
//       #define WPP_LOG_EXTRACT_CHECK(TYPE, VALUE, CHECK, LEVEL) CHECK
//       #define WPP_LOG_EXTRACT_LEVEL(TYPE, VALUE, CHECK, LEVEL) LEVEL 
//    c) указанные макросные функции вставляются в макрос WPP_LOG_ALWAYS 
//       без скобок (чтобы избежать преждевременного раскрытия). Скобки же 
//       подставляются при подстановке результата макроса 
//       WPP_EX_TRACELEVEL_<XXX>. 
///////////////////////////////////////////////////////////////////////////////
#if !defined WPP_CONTROL_GUIDS 
#ifdef WPP_DEBUG
#define WPP_INVOKE_WPP_DEBUG(MsgArgs) WPP_DEBUG(MsgArgs)
#else
#define WPP_INVOKE_WPP_DEBUG(MsgArgs) (void)0
#endif
#endif

// извлечение отдельных параметров 
#define WPP_LOG_EXTRACT_TYPE( TYPE, VALUE, CHECK, LEVEL)    TYPE
#define WPP_LOG_EXTRACT_VALUE(TYPE, VALUE, CHECK, LEVEL)    VALUE
#define WPP_LOG_EXTRACT_CHECK(TYPE, VALUE, CHECK, LEVEL)    CHECK
#define WPP_LOG_EXTRACT_LEVEL(TYPE, VALUE, CHECK, LEVEL)    LEVEL

// вывод в отладчик
#define WPP_LOG_ALWAYS(ARGS, ...)                {      \
    WPP_LOG_EXTRACT_TYPE ARGS WPP_VAR(__LINE__) =       \
        WPP_LOG_EXTRACT_VALUE ARGS;                     \
    if (WPP_LOG_EXTRACT_CHECK ARGS(WPP_VAR(__LINE__)))  \
    WppDebugPrint(										\
        WPP_LOG_EXTRACT_LEVEL ARGS,                  	\
        __FILE__, __LINE__, WPP_FUNC,                	\
        __VA_ARGS__                                     \
    ); 

///////////////////////////////////////////////////////////////////////////////
// Универсальные способы определения ошибки
///////////////////////////////////////////////////////////////////////////////
#define WPP_CAST_BOOL(code)      (code)

///////////////////////////////////////////////////////////////////////////////
// Переопределение функции трассировки для предотвращения изменения кода 
// последней ошибки в системе (что происходило в старых версиях функции 
// TraceMessage)
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS && !defined _NTDDK_
inline DWORD WppTraceMessage(
    IN TRACEHANDLE hLogger, IN ULONG messageFlags, 
    IN LPCGUID messageGuid, IN USHORT messageNumber, ...)
{
    // сохранить код последней ошибки
    DWORD lastError = ::GetLastError();

    // перейти на переменное число аргументов
    va_list args; va_start(args, messageNumber);

    // выполнить стандартную функцию трассировки
    DWORD code = CallTraceMessageVa(
        hLogger, messageFlags, messageGuid, messageNumber, args
    );
    // восстановить код ошибки
    va_end(args); ::SetLastError(lastError); return code; 
}
// функции трассировки и обработки событий 
#define WPP_REGISTER_TRACE_GUIDS    WppRegisterTraceGuids
#define WPP_UNREGISTER_TRACE_GUIDS  WppUnregisterTraceGuids
#define WPP_PRIVATE_ENABLE_CALLBACK WppNotificationCallback
#define WPP_TRACE                   WppTraceMessage
#endif 

///////////////////////////////////////////////////////////////////////////////
// Основная трассировка выполняется через функцию ATRACE(TRACELEVEL, MSG, ...), 
// второй параметр которой (строка форматирования) должен быть известен на 
// этапе компиляции. 
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC ATRACE(TRACELEVEL, MSG, ...);
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL(LEVEL)            (int, 1, WPP_CAST_BOOL, LEVEL)

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_PRE(LEVEL)           (void)WPP_VAR(__LINE__);

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_POST(LEVEL)          ;}

#ifdef WPP_CONTROL_GUIDS

// Описатель сеанса трассировки
#define WPP_TRACELEVEL_LOGGER(LEVEL)        WppGetLogger(),

// Проверка допустимости трассировки для указанного уровня
#define WPP_TRACELEVEL_ENABLED(LEVEL)       (WppGetControl()->Level >= LEVEL)

#else 

// Проверка допустимости трассировки
#define WPP_TRACELEVEL_ENABLED(LEVEL)       (1) 

// Вывод трассировки
#define ATRACE(LEVEL, ...)                                     \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL(LEVEL), __VA_ARGS__)      \
    WPP_TRACELEVEL_PRE(LEVEL)                                  \
    (void)((                                                   \
        WPP_TRACELEVEL_ENABLED(LEVEL)                          \
        ? WPP_INVOKE_WPP_DEBUG((__VA_ARGS__)), 1 : 0           \
    ))                                                         \
    WPP_TRACELEVEL_POST(LEVEL)                                       
#endif 

///////////////////////////////////////////////////////////////////////////////
// Передача строкового представления класса с функцией name()
///////////////////////////////////////////////////////////////////////////////
#define WPP_LOG_CPPNAME(x)     WPP_LOGPAIR((x).name().length() + 1, (x).name().c_str())

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок POSIX
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(POSIX, WPP_LOG_CPPNAME, const posix_error&, ItemString, "s", posix, 0);
// FUNC AE_CHECK_POSIX{TRACELEVEL=TRACE_LEVEL_ERROR}(POSIX);
// USESUFFIX(AE_CHECK_POSIX, "ERROR %!POSIX!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_POSIX(LEVEL, ERRNO)       	(int, ERRNO, WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_POSIX_PRE(LEVEL, ERRNO)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_POSIX_ENABLED(LEVEL, ERRNO)   	WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_POSIX_RAISE(FILE, LINE)                          \
    posix_exception(WPP_VAR(LINE), FILE, LINE).raise();    

// Проверка наличия ошибки
#define WPP_TRACELEVEL_POSIX_POST(LEVEL, ERRNO)                         \
    ; if (WPP_TRACELEVEL_POSIX_ENABLED(LEVEL, ERRNO)) {                 \
         WPP_TRACELEVEL_POSIX_RAISE(__FILE__, __LINE__)                 \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_POSIX_LOGGER(LEVEL, ERRNO)   	WppGetLogger(),
#else 
#define AE_CHECK_POSIX(ERRNO)                                                                     		    \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_POSIX(TRACE_LEVEL_ERROR, ERRNO), "ERROR %!POSIX!", WPP_VAR(__LINE__))  \
    WPP_TRACELEVEL_POSIX_PRE(TRACE_LEVEL_ERROR, ERRNO)                                            		    \
    (void)((                                                                                                \
        WPP_TRACELEVEL_POSIX_ENABLED(TRACE_LEVEL_ERROR, ERRNO)                                    		    \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!POSIX!", WPP_VAR(__LINE__))), 1 : 0                                \
    ))                                                                                            		    \
    WPP_TRACELEVEL_POSIX_POST(TRACE_LEVEL_ERROR, ERRNO)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок NTSTATUS
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_NTSTATUS{TRACELEVEL=TRACE_LEVEL_ERROR}(NTSTATUS);
// USESUFFIX(AE_CHECK_NTSTATUS, "ERROR %!STATUS!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_NTSTATUS(LEVEL, STATUS)        (NTSTATUS, STATUS, FAILED, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_NTSTATUS_PRE(LEVEL, STATUS)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_NTSTATUS_ENABLED(LEVEL, STATUS)   FAILED(WPP_VAR(__LINE__))

// Возбуждение исключения
#if defined _MANAGED && _MANAGED == 1
#define WPP_TRACELEVEL_NTSTATUS_RAISE(FILE, LINE)                           \
    windows_exception(native_error(WPP_VAR(LINE)), FILE, LINE).trace();     \
    throw gcnew System::ComponentModel::Win32Exception(                     \
        native_error(WPP_VAR(LINE)).value()                 		        \
    );  
#else
#define WPP_TRACELEVEL_NTSTATUS_RAISE(FILE, LINE)                           \
    windows_exception(native_error(WPP_VAR(LINE)), FILE, LINE).raise();
#endif 

// Проверка наличия ошибки
#define WPP_TRACELEVEL_NTSTATUS_POST(LEVEL, STATUS)                         \
    ; if (WPP_TRACELEVEL_NTSTATUS_ENABLED(LEVEL, STATUS)) {                 \
         WPP_TRACELEVEL_NTSTATUS_RAISE(__FILE__, __LINE__)                  \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_NTSTATUS_LOGGER(LEVEL, STATUS)    WppGetLogger(),
#else 
#define AE_CHECK_NTSTATUS(STATUS)                                                                                \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_NTSTATUS(TRACE_LEVEL_ERROR, STATUS), "ERROR %!STATUS!", WPP_VAR(__LINE__))  \
    WPP_TRACELEVEL_NTSTATUS_PRE(TRACE_LEVEL_ERROR, STATUS)                                                       \
    (void)((                                                                                                     \
        WPP_TRACELEVEL_NTSTATUS_ENABLED(TRACE_LEVEL_ERROR, STATUS)                                               \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!STATUS!", WPP_VAR(__LINE__))), 1 : 0                                    \
    ))                                                                                                           \
    WPP_TRACELEVEL_NTSTATUS_POST(TRACE_LEVEL_ERROR, STATUS)
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок HRESULT
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_HRESULT{TRACELEVEL=TRACE_LEVEL_ERROR}(HRESULT);
// USESUFFIX(AE_CHECK_HRESULT, "ERROR %!HRESULT!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_HRESULT(LEVEL, HR)        		(HRESULT, HR, FAILED, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_HRESULT_PRE(LEVEL, HR)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_HRESULT_ENABLED(LEVEL, HR)   		FAILED(WPP_VAR(__LINE__))

// Возбуждение исключения
#if defined _MANAGED && _MANAGED == 1
#define WPP_TRACELEVEL_HRESULT_RAISE(FILE, LINE)                            \
    windows_exception(hresult_error(WPP_VAR(LINE)), FILE, LINE).trace();    \
    throw gcnew System::ComponentModel::Win32Exception(WPP_VAR(LINE));  
#else
#define WPP_TRACELEVEL_HRESULT_RAISE(FILE, LINE)                            \
    windows_exception(hresult_error(WPP_VAR(LINE)), FILE, LINE).raise();
#endif 

// Проверка наличия ошибки
#define WPP_TRACELEVEL_HRESULT_POST(LEVEL, HR)                              \
    ; if (WPP_TRACELEVEL_HRESULT_ENABLED(LEVEL, HR)) {                      \
         WPP_TRACELEVEL_HRESULT_RAISE(__FILE__, __LINE__)                   \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_HRESULT_LOGGER(LEVEL, HR)    		WppGetLogger(),
#else 
#define AE_CHECK_HRESULT(HR)                                                                                  \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_HRESULT(TRACE_LEVEL_ERROR, HR), "ERROR %!HRESULT!", WPP_VAR(__LINE__))   \
    WPP_TRACELEVEL_HRESULT_PRE(TRACE_LEVEL_ERROR, HR)                                                         \
    (void)((                                                                                                  \
        WPP_TRACELEVEL_HRESULT_ENABLED(TRACE_LEVEL_ERROR, HR)                                                 \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!HRESULT!", WPP_VAR(__LINE__))), 1 : 0                                \
    ))                                                                                                        \
    WPP_TRACELEVEL_HRESULT_POST(TRACE_LEVEL_ERROR, HR)                                  
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок Windows 
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_WINERROR{TRACELEVEL=TRACE_LEVEL_ERROR}(WINERROR);
// USESUFFIX(AE_CHECK_WINERROR, "ERROR %!WINERROR!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_WINERROR(LEVEL, ERROR)        (DWORD, ERROR, WPP_CAST_BOOL, LEVEL)

// Сохранение кода ошибки
#define WPP_TRACELEVEL_WINERROR_PRE(LEVEL, ERROR)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_WINERROR_ENABLED(LEVEL, ERROR)   WPP_VAR(__LINE__)

// Возбуждение исключения
#if defined _MANAGED && _MANAGED == 1
#define WPP_TRACELEVEL_WINERROR_RAISE(FILE, LINE)                           \
    windows_exception(windows_error(WPP_VAR(LINE)), FILE, LINE).trace();    \
    throw gcnew System::ComponentModel::Win32Exception(                     \
        HRESULT_FROM_WIN32(WPP_VAR(LINE))                                   \
    );
#else
#define WPP_TRACELEVEL_WINERROR_RAISE(FILE, LINE)                           \
    windows_exception(windows_error(WPP_VAR(LINE)), FILE, LINE).raise();
#endif 

// Проверка наличия ошибки
#define WPP_TRACELEVEL_WINERROR_POST(LEVEL, ERROR)                          \
    ; if (WPP_TRACELEVEL_WINERROR_ENABLED(LEVEL, ERROR)) {                  \
         WPP_TRACELEVEL_WINERROR_RAISE(__FILE__, __LINE__)                  \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_WINERROR_LOGGER(LEVEL, ERROR)    WppGetLogger(),
#else 
#define AE_CHECK_WINERROR(ERROR)                                                                                     \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_WINERROR(TRACE_LEVEL_ERROR, ERROR), "ERROR %!WINERROR!", WPP_VAR(__LINE__))     \
    WPP_TRACELEVEL_WINERROR_PRE(TRACE_LEVEL_ERROR, ERROR)                                                            \
    (void)((                                                                                                         \
        WPP_TRACELEVEL_WINERROR_ENABLED(TRACE_LEVEL_ERROR, ERROR)                                                    \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!WINERROR!", WPP_VAR(__LINE__))), 1 : 0                                      \
    ))                                                                                                               \
    WPP_TRACELEVEL_WINERROR_POST(TRACE_LEVEL_ERROR, ERROR)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок WinAPI
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_WINAPI{TRACELEVEL=TRACE_LEVEL_ERROR}(WINAPI);
// USESUFFIX(AE_CHECK_WINAPI, "ERROR %!WINERROR!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_WINAPI(LEVEL, RET)            (DWORD, (RET) ? ERROR_SUCCESS : ::GetLastError(), WPP_CAST_BOOL, LEVEL)

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_WINAPI_PRE(LEVEL, RET)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_WINAPI_ENABLED(LEVEL, RET)       WPP_VAR(__LINE__)

// Проверка наличия ошибки
#define WPP_TRACELEVEL_WINAPI_POST(LEVEL, RET)                              \
    ; if (WPP_TRACELEVEL_WINAPI_ENABLED(LEVEL, RET)) {                      \
         WPP_TRACELEVEL_WINERROR_RAISE(__FILE__, __LINE__)                  \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_WINAPI_LOGGER(LEVEL, RET)        WppGetLogger(),
#else 
#define AE_CHECK_WINAPI(RET)                                                                                     \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_WINAPI(TRACE_LEVEL_ERROR, RET), "ERROR %!WINERROR!", WPP_VAR(__LINE__))     \
    WPP_TRACELEVEL_WINAPI_PRE(TRACE_LEVEL_ERROR, RET)                                                            \
    (void)((                                                                                                     \
        WPP_TRACELEVEL_WINAPI_ENABLED(TRACE_LEVEL_ERROR, RET)                                                    \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!WINERROR!", WPP_VAR(__LINE__))), 1 : 0                                  \
    ))                                                                                                           \
    WPP_TRACELEVEL_WINAPI_POST(TRACE_LEVEL_ERROR, RET)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок WinSock
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_WINSOCK{TRACELEVEL=TRACE_LEVEL_ERROR}(WINSOCK);
// USESUFFIX(AE_CHECK_WINSOCK, "ERROR %!WINERROR!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_WINSOCK(LEVEL, RET)           (DWORD, ((RET) >= 0) ? ERROR_SUCCESS : ::WSAGetLastError(), WPP_CAST_BOOL, LEVEL)

// Отсутствие дополнительных действий
#define WPP_TRACELEVEL_WINSOCK_PRE(LEVEL, RET)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_WINSOCK_ENABLED(LEVEL, RET)      WPP_VAR(__LINE__)

// Проверка наличия ошибки
#define WPP_TRACELEVEL_WINSOCK_POST(LEVEL, RET)                            \
    ; if (WPP_TRACELEVEL_WINSOCK_ENABLED(LEVEL, RET)) {                    \
         WPP_TRACELEVEL_WINERROR_RAISE(__FILE__, __LINE__)                 \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_WINSOCK_LOGGER(LEVEL, RET)        WppGetLogger(),
#else 
#define AE_CHECK_WINSOCK(RET)                                                                                 	\
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_WINSOCK(TRACE_LEVEL_ERROR, RET), "ERROR %!WINERROR!", WPP_VAR(__LINE__))   \
    WPP_TRACELEVEL_WINSOCK_PRE(TRACE_LEVEL_ERROR, RET)                                                          \
    (void)((                                                                                                    \
        WPP_TRACELEVEL_WINSOCK_ENABLED(TRACE_LEVEL_ERROR, RET)                                                  \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!WINERROR!", WPP_VAR(__LINE__)), 1 : 0                                	\
    ))                                                                                                          \
    WPP_TRACELEVEL_WINSOCK_POST(TRACE_LEVEL_ERROR, RET)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка системных ошибок 
// (признака завершения для WinAPI и кода завершения для POSIX)
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_SYSAPI{TRACELEVEL=TRACE_LEVEL_ERROR}(SYSAPI);
// USESUFFIX(AE_CHECK_SYSAPI, "ERROR %!WINERROR!", WPP_VAR(__LINE__));
// end_wpp

#if defined WPP_CONTROL_GUIDS

// Описатель сеанса трассировки
#define WPP_TRACELEVEL_SYSAPI_LOGGER(LEVEL, RET)    WPP_TRACELEVEL_WINAPI_LOGGER(LEVEL, RET)

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_SYSAPI(LEVEL, RET)        WPP_EX_TRACELEVEL_WINAPI(LEVEL, RET)

// Сохранение кода ошибки
#define WPP_TRACELEVEL_SYSAPI_PRE(LEVEL, RET)       WPP_TRACELEVEL_WINAPI_PRE(LEVEL, RET)

// Проверка наличия трассировки
#define WPP_TRACELEVEL_SYSAPI_ENABLED(LEVEL, RET)   WPP_TRACELEVEL_WINAPI_ENABLED(LEVEL, RET)

// Проверка наличия ошибки
#define WPP_TRACELEVEL_SYSAPI_POST(LEVEL, RET)      WPP_TRACELEVEL_WINAPI_POST(LEVEL, RET)

#elif defined _WIN32
#define AE_CHECK_SYSAPI(RET)    AE_CHECK_WINAPI(RET)
#else 
#define AE_CHECK_SYSAPI(CODE)   AE_CHECK_POSIX(CODE)
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка обобщенных ошибок 
// (с указанием кода для Windows и кода для POSIX)
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_RAISE_GENERIC{TRACELEVEL=TRACE_LEVEL_ERROR}(POSIX, WINERROR);
// USESUFFIX(AE_RAISE_GENERIC, "ERROR %!WINERROR!", WPP_VAR(__LINE__));
// end_wpp

#if defined WPP_CONTROL_GUIDS

// Описатель сеанса трассировки
#define WPP_TRACELEVEL_POSIX_WINERROR_LOGGER(LEVEL, ERRNO, ERROR)    WPP_TRACELEVEL_WINERROR_LOGGER(LEVEL, ERROR)

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_POSIX_WINERROR(LEVEL, ERRNO, ERROR)        WPP_EX_TRACELEVEL_WINERROR(LEVEL, ERROR)

// Сохранение кода ошибки
#define WPP_TRACELEVEL_POSIX_WINERROR_PRE(LEVEL, ERRNO, ERROR)       WPP_TRACELEVEL_WINERROR_PRE(LEVEL, ERROR)

// Проверка наличия трассировки
#define WPP_TRACELEVEL_POSIX_WINERROR_ENABLED(LEVEL, ERRNO, ERROR)   WPP_TRACELEVEL_WINERROR_ENABLED(LEVEL, ERROR)

// Проверка наличия ошибки
#define WPP_TRACELEVEL_POSIX_WINERROR_POST(LEVEL, ERRNO, ERROR)      WPP_TRACELEVEL_WINERROR_POST(LEVEL, ERROR)

#elif defined _WIN32
#define AE_RAISE_GENERIC(ERRNO, ERROR)   AE_CHECK_WINERROR(ERROR)
#else 
#define AE_RAISE_GENERIC(ERRNO, ERROR)   AE_CHECK_POSIX(ERRNO)
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок COM
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// FUNC AE_CHECK_COM{TRACELEVEL=TRACE_LEVEL_ERROR}(OBJ, IID, HRESULT);
// USESUFFIX(AE_CHECK_COM, "ERROR %!HRESULT!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_OBJ_IID_HRESULT(LEVEL, OBJ, IID, HR)        WPP_EX_TRACELEVEL_HRESULT(LEVEL, HR)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_PRE(LEVEL, OBJ, IID, HR)       WPP_TRACELEVEL_HRESULT_PRE(LEVEL, HR)

// Проверка наличия трассировки
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_ENABLED(LEVEL, OBJ, IID, HR)   WPP_TRACELEVEL_HRESULT_ENABLED(LEVEL, HR)

// Возбуждение исключения
#if defined _MANAGED && _MANAGED == 1
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_RAISE(OBJ, IID, FILE, LINE)                  \
    com_exception(OBJ, IID, WPP_VAR(LINE), FILE, LINE).trace();                     \
    throw gcnew System::ComponentModel::Win32Exception(WPP_VAR(LINE));  
#else
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_RAISE(OBJ, IID, FILE, LINE)                  \
    com_exception(OBJ, IID, WPP_VAR(LINE), FILE, LINE).raise();
#endif 

// Проверка наличия ошибки
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_POST(LEVEL, OBJ, IID, HR)                    \
    ; if (WPP_TRACELEVEL_OBJ_IID_HRESULT_ENABLED(LEVEL, OBJ, IID, HR)) {            \
         WPP_TRACELEVEL_OBJ_IID_HRESULT_RAISE(OBJ, IID, __FILE__, __LINE__)         \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_OBJ_IID_HRESULT_LOGGER(LEVEL, OBJ, IID, HR)    WPP_TRACELEVEL_HRESULT_LOGGER(LEVEL, HR)
#else 
#define AE_CHECK_COM(OBJ, IID, HR)                                                                                                \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_OBJ_IID_HRESULT(TRACE_LEVEL_ERROR, OBJ, IID, HR), "ERROR %!HRESULT!", WPP_VAR(__LINE__))     \
    WPP_TRACELEVEL_OBJ_IID_HRESULT_PRE(TRACE_LEVEL_ERROR, OBJ, IID, HR)                                                           \
    (void)((                                                                                                                      \
        WPP_TRACELEVEL_OBJ_IID_HRESULT_ENABLED(TRACE_LEVEL_ERROR, OBJ, IID, HR)                                                   \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!HRESULT!", WPP_VAR(__LINE__))), 1 : 0                                                    \
    ))                                                                                                                            \
    WPP_TRACELEVEL_OBJ_IID_HRESULT_POST(TRACE_LEVEL_ERROR, OBJ, IID, HR)                                  
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок PKCS11
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(PKCS11, WPP_LOG_CPPNAME, const pkcs11_error&, ItemString, "s", pkcs11, 0);
// FUNC AE_CHECK_PKCS11{TRACELEVEL=TRACE_LEVEL_ERROR}(PKCS11);
// USESUFFIX(AE_CHECK_PKCS11, "ERROR %!PKCS11!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_PKCS11(LEVEL, CODE)       	(CK_ULONG, CODE, WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_PKCS11_PRE(LEVEL, CODE)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_PKCS11_ENABLED(LEVEL, CODE)   	WPP_VAR(__LINE__)

// Возбуждение исключения
#if defined _MANAGED && _MANAGED == 1
#define WPP_TRACELEVEL_PKCS11_RAISE(FILE, LINE)    	                        \
    pkcs11_exception(WPP_VAR(LINE), FILE, LINE).trace();                    \
    throw gcnew Aladdin::PKCS11::Exception(WPP_VAR(LINE));
#else 
#define WPP_TRACELEVEL_PKCS11_RAISE(FILE, LINE)           	                \
    pkcs11_exception(WPP_VAR(LINE), FILE, LINE).raise();    
#endif 

// Проверка наличия ошибки
#define WPP_TRACELEVEL_PKCS11_POST(LEVEL, CODE)                             \
    ; if (WPP_TRACELEVEL_PKCS11_ENABLED(LEVEL, CODE)) {                     \
         WPP_TRACELEVEL_PKCS11_RAISE(__FILE__, __LINE__)                    \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_PKCS11_LOGGER(LEVEL, CODE)   	WppGetLogger(),
#else 
#define AE_CHECK_PKCS11(CODE)                                                               			    	\
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_PKCS11(TRACE_LEVEL_ERROR, CODE), "ERROR %!PKCS11!", WPP_VAR(__LINE__))   	\
    WPP_TRACELEVEL_PKCS11_PRE(TRACE_LEVEL_ERROR, CODE)                               	            			\
    (void)((                                                                                      			    \
        WPP_TRACELEVEL_PKCS11_ENABLED(TRACE_LEVEL_ERROR, CODE)                       	            			\
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!PKCS11!", WPP_VAR(__LINE__))), 1 : 0                                	\
    ))                                                                                      					\
    WPP_TRACELEVEL_PKCS11_POST(TRACE_LEVEL_ERROR, CODE)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок OpenSSL
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(OPENSSL, WPP_LOG_CPPNAME, const openssl_error&, ItemString, "s", openssl, 0);
// FUNC AE_CHECK_OPENSSL{TRACELEVEL=TRACE_LEVEL_ERROR}(OPENSSL);
// USESUFFIX(AE_CHECK_OPENSSL, "ERROR %!OPENSSL!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_OPENSSL(LEVEL, RET)       	(unsigned long, (RET) ? 0 : ERR_get_error(), WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_OPENSSL_PRE(LEVEL, RET)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_OPENSSL_ENABLED(LEVEL, RET)   	WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_OPENSSL_RAISE(FILE, LINE)                            \
    openssl_exception(WPP_VAR(LINE), FILE, LINE).raise();    

// Проверка наличия ошибки
#define WPP_TRACELEVEL_OPENSSL_POST(LEVEL, RET)                             \
    ; if (WPP_TRACELEVEL_OPENSSL_ENABLED(LEVEL, RET)) {                     \
         WPP_TRACELEVEL_OPENSSL_RAISE(__FILE__, __LINE__)                   \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_OPENSSL_LOGGER(LEVEL, RET)   	WppGetLogger(),
#else 
#define AE_CHECK_OPENSSL(RET)                                                                     		        \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_OPENSSL(TRACE_LEVEL_ERROR, RET), "ERROR %!OPENSSL!", WPP_VAR(__LINE__))    \
    WPP_TRACELEVEL_OPENSSL_PRE(TRACE_LEVEL_ERROR, RET)                                            		        \
    (void)((                                                                                                    \
        WPP_TRACELEVEL_OPENSSL_ENABLED(TRACE_LEVEL_ERROR, RET)                                    		        \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!OPENSSL!", WPP_VAR(__LINE__))), 1 : 0                                  \
    ))                                                                                            		        \
    WPP_TRACELEVEL_OPENSSL_POST(TRACE_LEVEL_ERROR, RET)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок ODBC
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(ODBC, WPP_LOG_CPPNAME, const odbc_error&, ItemString, "s", odbc, 0);
// FUNC AE_CHECK_ODBC{TRACELEVEL=TRACE_LEVEL_ERROR}(CAT, HANDLE, TYPE, ODBC);
// USESUFFIX(AE_CHECK_ODBC, "ERROR %!ODBC!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_CAT_HANDLE_TYPE_ODBC(LEVEL, CAT, HANDLE, TYPE, ODBC)       	(odbc_error, odbc_error(CAT, ODBC), WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_PRE(LEVEL, CAT, HANDLE, TYPE, ODBC)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_ENABLED(LEVEL, CAT, HANDLE, TYPE, ODBC)   	WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_RAISE(HANDLE, TYPE, FILE, LINE)    	                \
    odbc_exception(WPP_VAR(LINE), HANDLE, TYPE, FILE, LINE).raise();    

// Проверка наличия ошибки
#define WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_POST(LEVEL, CAT, HANDLE, TYPE, ODBC)                \
    ; if (WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_ENABLED(LEVEL, CAT, HANDLE, TYPE, ODBC)) {        \
         WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_RAISE(HANDLE, TYPE, __FILE__, __LINE__)            \
    }}

// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_LOGGER(LEVEL, CAT, HANDLE, TYPE, ODBC)   	WppGetLogger(),
#else 
#define AE_CHECK_ODBC(CAT, HANDLE, TYPE, ODBC)                                                               			            		\
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_CAT_HANDLE_TYPE_ODBC(TRACE_LEVEL_ERROR, CAT, HANDLE, TYPE, ODBC), "ERROR %!ODBC!", WPP_VAR(__LINE__))  \
    WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_PRE(TRACE_LEVEL_ERROR, CAT, HANDLE, TYPE, ODBC)                               	            		\
    (void)((                                                                                      							            	\
        WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_ENABLED(TRACE_LEVEL_ERROR, CAT, HANDLE, TYPE, ODBC)                       	            		\
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!ODBC!", WPP_VAR(__LINE__))), 1 : 0                                									\
    ))                                                                                      							            		\
    WPP_TRACELEVEL_CAT_HANDLE_TYPE_ODBC_POST(TRACE_LEVEL_ERROR, CAT, HANDLE, TYPE, ODBC)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок OCI
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(OCI, WPP_LOG_CPPNAME, const oci_error&, ItemString, "s", oci, 0);
// FUNC AE_CHECK_OCI{TRACELEVEL=TRACE_LEVEL_ERROR}(CAT, OCI, ERROR);
// USESUFFIX(AE_CHECK_OCI, "ERROR %!OCI!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_CAT_OCI_ERROR(LEVEL, CAT, OCI, ERROR)       	(oci_error, oci_error(CAT, OCI), WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_CAT_OCI_ERROR_PRE(LEVEL, CAT, OCI, ERROR)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_CAT_OCI_ERROR_ENABLED(LEVEL, CAT, OCI, ERROR)    WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_CAT_OCI_ERROR_RAISE(ERROR, FILE, LINE)    	        \
    oci_exception(WPP_VAR(LINE), ERROR, FILE, LINE).raise();

// Проверка наличия ошибки
#define WPP_TRACELEVEL_CAT_OCI_ERROR_POST(LEVEL, CAT, OCI, ERROR)           \
    ; if (WPP_TRACELEVEL_CAT_OCI_ERROR_ENABLED(LEVEL, CAT, OCI, ERROR)) {   \
         WPP_TRACELEVEL_CAT_OCI_ERROR_RAISE(ERROR, __FILE__, __LINE__)  	\
    }}
// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_CAT_OCI_ERROR_LOGGER(LEVEL, CAT, OCI, ERROR)   	WppGetLogger(),
#else
#define AE_CHECK_OCI(CAT, OCI, ERROR)                                                                           			\
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_CAT_OCI_ERROR(TRACE_LEVEL_ERROR, CAT, OCI, ERROR), "ERROR %!OCI!", WPP_VAR(__LINE__))  \
    WPP_TRACELEVEL_CAT_OCI_ERROR_PRE(TRACE_LEVEL_ERROR, CAT, OCI, ERROR)                               	        			\
    (void)((                                                                                                          		\
        WPP_TRACELEVEL_CAT_OCI_ERROR_ENABLED(TRACE_LEVEL_ERROR, CAT, OCI, ERROR)                       	        			\
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!OCI!", WPP_VAR(__LINE__))), 1 : 0                                		            \
    ))                                                                                                          			\
    WPP_TRACELEVEL_CAT_OCI_ERROR_POST(TRACE_LEVEL_ERROR, CAT, OCI, ERROR)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок LIBPQ
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(LIBPQ, WPP_LOG_CPPNAME, const libpq_error&, ItemString, "s", libpq, 0);
// FUNC AE_CHECK_LIBPQ{TRACELEVEL=TRACE_LEVEL_ERROR}(LIBPQ);
// USESUFFIX(AE_CHECK_LIBPQ, "ERROR %!LIBPQ!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_LIBPQ(LEVEL, RESULT)        (libpq_error, libpq_error(RESULT), WPP_CAST_BOOL, LEVEL)

// Сохранение кода ошибки
#define WPP_TRACELEVEL_LIBPQ_PRE(LEVEL, RESULT)       

// Проверка наличия трассировки
#define WPP_TRACELEVEL_LIBPQ_ENABLED(LEVEL, RESULT)   WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_LIBPQ_RAISE(FILE, LINE)                          \
    libpq_exception(WPP_VAR(LINE), FILE, LINE).raise();

// Проверка наличия ошибки
#define WPP_TRACELEVEL_LIBPQ_POST(LEVEL, RESULT)                        \
    ; if (WPP_TRACELEVEL_LIBPQ_ENABLED(LEVEL, RESULT)) {                \
         WPP_TRACELEVEL_LIBPQ_RAISE(__FILE__, __LINE__)                 \
    }}
// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_LIBPQ_LOGGER(LEVEL, RESULT)    WppGetLogger(),
#else 
#define AE_CHECK_LIBPQ(RESULT)                                                                          	    \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_LIBPQ(TRACE_LEVEL_ERROR, RESULT), "ERROR %!LIBPQ!", WPP_VAR(__LINE__))     \
    WPP_TRACELEVEL_LIBPQ_PRE(TRACE_LEVEL_ERROR, RESULT)                                               		    \
    (void)((                                                                                                  	\
        WPP_TRACELEVEL_LIBPQ_ENABLED(TRACE_LEVEL_ERROR, RESULT)                                         	    \
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!LIBPQ!", WPP_VAR(__LINE__))), 1 : 0                                    \
    ))                                                                                                  	    \
    WPP_TRACELEVEL_LIBPQ_POST(TRACE_LEVEL_ERROR, RESULT)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Трассировка ошибок Python
///////////////////////////////////////////////////////////////////////////////
// begin_wpp config
// DEFINE_CPLX_TYPE(PYTHON, WPP_LOG_CPPNAME, const python_error&, ItemString, "s", python, 0);
// FUNC AE_CHECK_PYTHON{TRACELEVEL=TRACE_LEVEL_ERROR}(PYTHON);
// USESUFFIX(AE_CHECK_PYTHON, "ERROR %!PYTHON!", WPP_VAR(__LINE__));
// end_wpp

// Параметры трассировки для отладчика
#define WPP_EX_TRACELEVEL_PYTHON(LEVEL, CAT)       	    (python_error, CAT, WPP_CAST_BOOL, LEVEL)

// Отсутствие предварительных действий
#define WPP_TRACELEVEL_PYTHON_PRE(LEVEL, CAT)      

// Проверка наличия трассировки
#define WPP_TRACELEVEL_PYTHON_ENABLED(LEVEL, CAT)   	WPP_VAR(__LINE__)

// Возбуждение исключения
#define WPP_TRACELEVEL_PYTHON_RAISE(FILE, LINE)    	                    \
    python_exception(WPP_VAR(LINE), FILE, LINE).raise();    

// Проверка наличия ошибки
#define WPP_TRACELEVEL_PYTHON_POST(LEVEL, CAT)                          \
    ; if (WPP_TRACELEVEL_PYTHON_ENABLED(LEVEL, CAT)) {                  \
         WPP_TRACELEVEL_PYTHON_RAISE(__FILE__, __LINE__)	            \
    }}
// Определение трассировки
#if defined WPP_CONTROL_GUIDS
#define WPP_TRACELEVEL_PYTHON_LOGGER(LEVEL, CAT)   	WppGetLogger(),
#else 
#define AE_CHECK_PYTHON(CAT)                                                               			            \
    WPP_LOG_ALWAYS(WPP_EX_TRACELEVEL_PYTHON(TRACE_LEVEL_ERROR, CAT), "ERROR %!PYTHON!", WPP_VAR(__LINE__))  	\
    WPP_TRACELEVEL_PYTHON_PRE(TRACE_LEVEL_ERROR, CAT)                               	            			\
    (void)((                                                                                      			    \
        WPP_TRACELEVEL_PYTHON_ENABLED(TRACE_LEVEL_ERROR, CAT)                       	            			\
        ? WPP_INVOKE_WPP_DEBUG(("ERROR %!PYTHON!", WPP_VAR(__LINE__))), 1 : 0                                	\
    ))                                                                                      					\
    WPP_TRACELEVEL_PYTHON_POST(TRACE_LEVEL_ERROR, CAT)                                      
#endif 

///////////////////////////////////////////////////////////////////////////////
// Стандартные определения трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#define WPP_USER_MSG_GUID (77921413, 5345, 4626, B028, C3AFB9DCBF05)
#if defined _NTDDK_
#include "TraceDriver.h"
#else 
#include "TraceUser.h"
#endif 
#else 
#if defined _NTDDK_
#define WPP_INIT_TRACING(pDriver, pRegPath) UNREFERENCED_PARAMETER(pRegPath)
#define WPP_CLEANUP(     pDriver)           UNREFERENCED_PARAMETER(pDriver) 
#else 
#define WPP_INIT_TRACING(Application)       ((void)0)
#define WPP_CLEANUP(                )       ((void)0)
#endif 
#endif 

///////////////////////////////////////////////////////////////////////////////
// Найти описание провайдера трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
inline PWPP_TRACE_CONTROL_BLOCK WppGetControl(TRACEHANDLE hRegistrationHandle)
{
    // проверить наличие регистрации
    if (WPP_CB == (WPP_CB_TYPE*)&WPP_CB) return nullptr; 

    // перейти на блок первого компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = &WPP_CB[0].Control;

    // для всех зарегистрированных компонентов
    for(; pControl; pControl = pControl->Next) 
    {
        // проверить наличие идентификатора
        if (!pControl->ControlGuid) continue; 
#if defined _NTDDK_
        // проверить совпадение идентификатора
        if (pControl->RegHandle == hRegistrationHandle) return pControl;
#else 
        // проверить совпадение идентификатора
        if (pControl->UmRegistrationHandle == hRegistrationHandle) return pControl;
#endif 
    }
    return nullptr; 
}

inline PWPP_TRACE_CONTROL_BLOCK WppGetControl(const GUID& componentGUID)
{
    // проверить наличие регистрации
    if (WPP_CB == (WPP_CB_TYPE*)&WPP_CB) return nullptr; 

    // перейти на блок первого компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = &WPP_CB[0].Control;

    // для всех зарегистрированных компонентов
    for(; pControl; pControl = pControl->Next) 
    {
        // проверить наличие идентификатора
        if (!pControl->ControlGuid) continue; 

        // проверить совпадение идентификатора
        if (IsEqualGUID(*pControl->ControlGuid, componentGUID)) return pControl;
    }
    return nullptr; 
}

inline PWPP_TRACE_CONTROL_BLOCK WppGetControl()
{
    // указать идентификатор компонента
    GUID componentGUID = WPP_XGLUE4(WPP_, ThisDir, _CTLGUID_, WPP_EVAL(WPP_CONTROL_NAME)); 

    // найти блок компонента
    return WppGetControl(componentGUID); 
}

inline TRACEHANDLE WppGetLogger()
{
    // найти блок компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(); 

#if !defined _NTDDK_
    // для специального случая
    if (pControl && pControl->Options == WPP_VER_WIN2K_CB_FORWARD_PTR)
    {
        // вернуть описатель сеанса
        if (pControl->Win2kCb) return pControl->Win2kCb->Logger; 
    }
    // для специального случая
    if (pControl && pControl->Options == WPP_VER_WHISTLER_CB_FORWARD_PTR)
    {
        // скорректировать блок компонента
        if (pControl->Cb) pControl = pControl->Cb; 
    }
#endif 
    // вернуть описатель сеанса
    return (pControl) ? pControl->Logger : 0; 
}

///////////////////////////////////////////////////////////////////////////////
// Регистрация идентификаторов трассировки
///////////////////////////////////////////////////////////////////////////////
#if !defined _NTDDK_
inline ULONG WppRegisterTraceGuids(
    WMIDPREQUEST RequestAddress, PVOID RequestContext, 
    LPCGUID ControlGuid, ULONG GuidCount, PTRACE_GUID_REGISTRATION TraceGuidReg, 
    LPCWSTR MofImagePath, LPCWSTR MofResourceName, PTRACEHANDLE phRegistrationHandle)
{
    // вызвать базовую функцию
    ULONG ret = ::RegisterTraceGuidsW(RequestAddress, RequestContext, 
        ControlGuid, GuidCount, TraceGuidReg, 
        MofImagePath, MofResourceName, phRegistrationHandle
    ); 
    // проверить отсутствие ошибок
    if (ret != ERROR_SUCCESS) return ret; 

    // найти основной блок управления
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(*phRegistrationHandle); 

    // проверить корректность настроек
    if (!pControl || pControl->Options != 0) return ret; 

    // выделить память для дополнительного блока управления
    if (PWPP_TRACE_CONTROL_BLOCK pCB = new WPP_TRACE_CONTROL_BLOCK)
    {
        // выполнить инициализацию
        pCB->Options = 0; pCB->Logger = pControl->Logger; 

        // указать используемое перенаправление
        pControl->Options = WPP_VER_WHISTLER_CB_FORWARD_PTR; pControl->Cb = pCB; 

        // указать данные основного блока управления
        pCB->UmRegistrationHandle = pControl->UmRegistrationHandle; 

        // указать данные основного блока управления
        pCB->ControlGuid = ControlGuid; pCB->Level = pControl->Level; 
        
        // указать данные основного блока управления
        pCB->FlagsLen = pControl->FlagsLen; pCB->Flags[0] = pControl->Flags[0]; 

        // прочитать параметры трассировки
        trace::ControlParameters* pControlParameters = new(std::nothrow) trace::ControlParameters(); 

        // сохранить значения параметров трассировки
        pCB->Next = (PWPP_TRACE_CONTROL_BLOCK)pControlParameters; 
    }
    return ret; 
}

inline ULONG WppUnregisterTraceGuids(TRACEHANDLE hRegistrationHandle)
{
    // найти основной блок управления
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(hRegistrationHandle); 

    // проверить корректность настроек
    if (pControl && pControl->Options == WPP_VER_WHISTLER_CB_FORWARD_PTR) 
    {
        // получить адрес дополнительного блока
        if (PWPP_TRACE_CONTROL_BLOCK pCB = pControl->Cb)
        {        
            // восстановить исходные данные
            pControl->Options = 0; pControl->Logger = pCB->Logger; 

            // восстановить исходные данные
            pControl->UmRegistrationHandle = pCB->UmRegistrationHandle; 
            
            // восстановить исходные данные
            pControl->ControlGuid = pCB->ControlGuid; pControl->Level = pCB->Level; 

            // восстановить исходные данные
            pControl->FlagsLen = pCB->FlagsLen; pControl->Flags[0] = pCB->Flags[0];

            // освободить выделенную память
            if (pCB->Next) delete (trace::ControlParameters*)(pCB->Next); delete pCB; 
        }
    }
    // вызвать базовую функцию
    return ::UnregisterTraceGuids(hRegistrationHandle); 
}
#endif 

///////////////////////////////////////////////////////////////////////////////
// Обработка событий трассировки
///////////////////////////////////////////////////////////////////////////////
#if defined _NTDDK_
inline void WppNotificationCallback(LPCGUID, TRACEHANDLE, BOOLEAN, ULONG, UCHAR) {}
#else 
inline void WppNotificationCallback(LPCGUID ControlGuid, 
    TRACEHANDLE hLogger, BOOLEAN enable, ULONG flags, UCHAR level) 
{
    // найти основной блок управления
    if (!enable) return; PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(*ControlGuid); 

    // проверить корректность настроек
    if (!pControl || pControl->Options != WPP_VER_WHISTLER_CB_FORWARD_PTR) return; 

    // получить адрес дополнительного блока
    if (PWPP_TRACE_CONTROL_BLOCK pCB = pControl->Cb)
    {
        // сохранить принятые данные
        pCB->Logger = hLogger; pCB->Level = level; pCB->Flags[0] = flags; 

        // обновить параметры трассировки
        ((trace::ControlParameters*)(pCB->Next))->Update(); 
    }
}
namespace trace {
inline const ControlParameters* GetControlParameters() 
{
    // найти блок компонента
    PWPP_TRACE_CONTROL_BLOCK pControl = WppGetControl(); if (!pControl) return nullptr; 
    
    // проверить наличие блока
    if (pControl->Options != WPP_VER_WHISTLER_CB_FORWARD_PTR || !pControl->Cb) return nullptr; 

    // выполнить преобразование типа
    return (const ControlParameters*)(pControl->Cb->Next); 
}
}
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
// Трассировка входа/выхода из функции. Функции класса не должны быть 
// встраиваемыми (inline) во избежание следующих проблем: 
// 1) неcоответствия принадлежности конструктора и деструктора класса 
// различным единицам трансляции и, следовательно, рассогласования при выводе 
// трассировки (различные значения __FILE__ и принадлежность номеров строк
// различным файлам); 
// 2) помещения в .TMF-файл для трассировочных сообщений Trace.h описания 
// сообщений, принадлежащих другим единицам трансляции (единицам трансляции, 
// в которые встраиваются вызовы конструктора и деструктора). 
///////////////////////////////////////////////////////////////////////////////
namespace trace { 
class scope { private: const char* szFunction; 

    // конструктор
    public: WPP_NOINLINE scope(const char* szFunc) : szFunction(szFunc)
    {
        // выполнить трассировку входа
        ATRACE(TRACE_LEVEL_VERBOSE, "--> %hs", szFunction);
    }
    // деструктор
    public: WPP_NOINLINE ~scope()
    {
        // выполнить трассировку выхода
        ATRACE(TRACE_LEVEL_VERBOSE, "<-- %hs", szFunction);
    }
};    
}
// встраивание трассировки стека
#define $ trace::scope WPP_VAR(__LINE__)(WPP_FUNC);

///////////////////////////////////////////////////////////////////////////////
// Трассировка строки фиксированного размера
///////////////////////////////////////////////////////////////////////////////
WPP_NOINLINE inline void WppTraceStringA(int level, const char* sz, size_t cch) 
{ 
    // определить размер строки
    if (!sz) { return; } if (cch == (size_t)(-1)) { cch = strlen(sz); } switch (level)
    {
    // вывести строку
    case TRACE_LEVEL_NONE       : ATRACE(TRACE_LEVEL_NONE       , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_CRITICAL   : ATRACE(TRACE_LEVEL_CRITICAL   , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_ERROR      : ATRACE(TRACE_LEVEL_ERROR      , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_WARNING    : ATRACE(TRACE_LEVEL_WARNING    , "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_INFORMATION: ATRACE(TRACE_LEVEL_INFORMATION, "%!.*hs!", trace::_str(sz, cch)); break;
    case TRACE_LEVEL_VERBOSE    : ATRACE(TRACE_LEVEL_VERBOSE    , "%!.*hs!", trace::_str(sz, cch)); break;
    }
}

WPP_NOINLINE inline void WppTraceStringW(int level, const wchar_t* sz, size_t cch) 
{ 
    // определить размер строки
    if (!sz) { return; } if (cch == (size_t)(-1)) { cch = wcslen(sz); } switch (level)
    {
    // вывести строку
    case TRACE_LEVEL_NONE       : ATRACE(TRACE_LEVEL_NONE       , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_CRITICAL   : ATRACE(TRACE_LEVEL_CRITICAL   , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_ERROR      : ATRACE(TRACE_LEVEL_ERROR      , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_WARNING    : ATRACE(TRACE_LEVEL_WARNING    , "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_INFORMATION: ATRACE(TRACE_LEVEL_INFORMATION, "%!.*ls!", trace::_wstr(sz, cch)); break;
    case TRACE_LEVEL_VERBOSE    : ATRACE(TRACE_LEVEL_VERBOSE    , "%!.*ls!", trace::_wstr(sz, cch)); break;
    }
}
inline void ATRACESTR(int level, const char   * sz, size_t cch = -1) { WppTraceStringA(level, sz, cch); }
inline void ATRACESTR(int level, const wchar_t* sz, size_t cch = -1) { WppTraceStringW(level, sz, cch); }

///////////////////////////////////////////////////////////////////////////////
// Выполнить трассировку содержимого буфера
///////////////////////////////////////////////////////////////////////////////
inline void ATRACEDUMP(int level, const void* pvBlock, size_t cbBlock)
{
    static const char DIGITS[] = {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };
    // выполнить преобразование типа
    const unsigned char* pbBlock = (const unsigned char*)pvBlock; 

    // создать буфер требуемого размера
    char buffer[2 * sizeof(void*) + 2 + 64 + 1] = {0}; 

    // определить адрес для форматируемого значения
    char* szValue = buffer + 2 * sizeof(void*) + 2; 

    // для всех строк
    for (size_t i = 0; i < (cbBlock + 15) / 16; i++)
    {
        // вычислить базовый адрес
        const unsigned char* ptr = pbBlock + i * 16; memset(szValue, ' ', 64);

        // отформатировать адрес
        trace::snprintf_ptr(buffer, 2 * sizeof(void*) + 1, ptr); 

        // указать разделитель адреса и значения
        buffer[2 * sizeof(void*) + 0] = ':'; buffer[2 * sizeof(void*) + 1] = ' '; 

        // для всех байтов строки
        for (size_t j = 0; (j < 16) && (i * 16 + j < cbBlock); j++)
        {
            // извлечь отдельный байт
            unsigned char ch = ptr[j];

            // указать шестнадцатеричное представление
            szValue[j * 3 + 0] = DIGITS[ch / 16];
            szValue[j * 3 + 1] = DIGITS[ch % 16];

            // указать символьное представление
            szValue[48 + j] = (' ' <= ch && ch <= 127) ? ch : '.';
        }
        // выполнить трассировку
        ATRACESTR(level, buffer);
    }                                                                   
}

///////////////////////////////////////////////////////////////////////////////
// Выполнить многострочную трассировку ошибки
///////////////////////////////////////////////////////////////////////////////
inline void ATRACE_MULTILINE(int level, const char* szMessage)
{
    // для всех подстрок
    while (szMessage && *szMessage)
    {
        // найти завершение подстроки
        if (const char* szLast = strchr(szMessage, '\n')) 
        { 
            // указать позицию окончания вывода
            const char* szEnd = szLast; if (szLast != szMessage)
            {
                // указать позицию окончания вывода
                if (*(szLast - 1) == '\r') szEnd--; 
            }
            // вывести подстроку
            ATRACESTR(level, szMessage, szEnd - szMessage);

            // пропустить подстроку
            szMessage = szLast + 1; continue; 
        }
        // вывести оставшуюся строку
        ATRACESTR(level, szMessage); break; 
    }
}
inline void ATRACE_MULTILINE(int level, const wchar_t* szMessage)
{
    // для всех подстрок
    while (szMessage && *szMessage)
    {
        // найти завершение подстроки
        if (const wchar_t* szLast = wcschr(szMessage, L'\n')) 
        { 
            // указать позицию окончания вывода
            const wchar_t* szEnd = szLast; if (szLast != szMessage)
            {
                // указать позицию окончания вывода
                if (*(szLast - 1) == L'\r') szEnd--; 
            }
            // вывести подстроку
            ATRACESTR(level, szMessage, szEnd - szMessage);

            // пропустить подстроку
            szMessage = szLast + 1; continue; 
        }
        // вывести оставшуюся строку
        ATRACESTR(level, szMessage); break; 
    }
}

///////////////////////////////////////////////////////////////////////////////
// Сбросить идентификатор служебных сообщений
///////////////////////////////////////////////////////////////////////////////
#if defined WPP_CONTROL_GUIDS
#undef WPP_USER_MSG_GUID
#endif 

///////////////////////////////////////////////////////////////////////////////
// Определение ошибок
///////////////////////////////////////////////////////////////////////////////
#if !defined _NTDDK_
#include "TraceError.h"     // определение ошибок
#include "TracePosix.h"     // определение ошибок POSIX

#if defined _WIN32
#include "TraceWindows.h"   // определение ошибок Windows
#include "TraceCOM.h"       // определение ошибок COM
#endif 
#endif 
